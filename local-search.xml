<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>加密 frp 配置教程</title>
    <link href="/posts/e8847680/"/>
    <url>/posts/e8847680/</url>
    
    <content type="html"><![CDATA[<p>本篇文章中，记录了如何对 frpc 和 frps 之间的通信内容进行加密，从而有效防止传输内容被截取，保证系统的安全性。</p><blockquote><p>从 v0.52.0 版本开始，frp 开始支持 TOML、YAML 和 JSON 作为配置文件格式。</p><p>请注意，INI 已被弃用，并将在未来的发布中移除。新功能只能在 TOML、YAML 或 JSON 中使用。</p><p><strong>建议使用 TOML 作为配置文件格式。</strong></p></blockquote><blockquote><p>应始终使用最新的 frpc 和 frps 的软件版本，新版本通常修复了已知的安全漏洞和问题。</p></blockquote><h1 id="0-提高安全性的方法"><a href="#0-提高安全性的方法" class="headerlink" title="0 提高安全性的方法"></a>0 提高安全性的方法</h1><h2 id="0-1-为-token-配置强密码"><a href="#0-1-为-token-配置强密码" class="headerlink" title="0.1 为 token 配置强密码"></a>0.1 为 token 配置强密码</h2><p>可以使用 <a href="https://tool.chinaz.com/tools/randompwd/">随机密码生成器</a> 来生成包含大小写字母、数字和特殊字符的组合，并定期更改 token。</p><h2 id="0-2-修改默认端口"><a href="#0-2-修改默认端口" class="headerlink" title="0.2 修改默认端口"></a>0.2 修改默认端口</h2><p>frps 的配置文件中默认使用 7000 端口，建议改为高位端口号。</p><h2 id="0-3-限制访问来源"><a href="#0-3-限制访问来源" class="headerlink" title="0.3 限制访问来源"></a>0.3 限制访问来源</h2><p>一种方式是可以设置 frp 服务端只接受目标范围的 IP 进行链接，但不适合客户端经常更新 IP 的情形。</p><p>另一种方式是只允许特定用户与 frp 服务端进行链接，frp 还支持受控端进行用户访问控制。</p><h2 id="0-4-使用-stcp"><a href="#0-4-使用-stcp" class="headerlink" title="0.4 使用 stcp"></a>0.4 使用 stcp</h2><p>某些内网服务如果直接暴漏在公网可能存在安全风险，使用 <code>stcp(secret tcp)</code> 类型的代理可以实现将内网服务暴漏给经过授权的用户，但是访问者也需要运行另外一个 frpc 客户端。</p><p><img src="/img/frp/stcp.png"></p><h2 id="0-5-自定义-TLS-加密"><a href="#0-5-自定义-TLS-加密" class="headerlink" title="0.5 自定义 TLS 加密"></a>0.5 自定义 TLS 加密</h2><p><code>STCP</code> 等功能能有效防止流量内容在通信过程中被盗取，但是无法判断对方的身份是否合法，存在被中间人攻击的风险。为此 frp 支持 frpc 和 frps 之间的流量通过 TLS 协议加密，并且支持客户端或服务端单向验证，双向验证等功能。</p><p>当 <code>frps.toml</code> 中 <code>transport.tls.force = true</code> 时，表示 server 端只接受 TLS 连接的客户端，这也是 frps 验证 frpc 身份的前提条件。如果 <code>frps.toml</code> 中 <code>transport.tls.trustedCaFile</code> 内容是有效的话，那么默认就会开启 <code>transport.tls.force = true</code>。</p><blockquote><p><strong>从 v0.50.0 开始，<code>transport.tls.enable</code> 的默认值将会为 true，默认开启 TLS 协议加密。</strong></p><p><strong>如果 frps 端没有配置证书，则会使用随机生成的证书来加密流量。</strong></p><p><strong>默认情况下，frpc 开启 TLS 加密功能，但是不校验 frps 的证书。</strong></p></blockquote><h1 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h1><p>frp 采用 Golang 编写，支持跨平台，仅需下载对应平台的二进制文件即可执行，没有额外依赖。</p><p>可以在 Github 的 <a href="https://github.com/fatedier/frp/releases">Release</a> 页面中下载到最新版本的客户端和服务端二进制文件，所有文件被打包在一个压缩包中。</p><h1 id="2-生成加密证书"><a href="#2-生成加密证书" class="headerlink" title="2 生成加密证书"></a>2 生成加密证书</h1><p>双向验证应该是目前最安全的方案。启用双向验证需要先生成证书。</p><p>首先建立一个文件夹，后续在该目录内进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /path/to/save<br><span class="hljs-built_in">cd</span> /path/to/save<br></code></pre></td></tr></table></figure><h2 id="2-1-准备-my-openssl-cnf-文件"><a href="#2-1-准备-my-openssl-cnf-文件" class="headerlink" title="2.1 准备 my-openssl.cnf 文件"></a>2.1 准备 <code>my-openssl.cnf</code> 文件</h2><p>将以下配置写入 <code>my-openssl.cnf</code> 文件。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ ca ]</span><br><span class="hljs-attr">default_ca</span> = CA_default<br><span class="hljs-section">[ CA_default ]</span><br><span class="hljs-attr">x509_extensions</span> = usr_cert<br><span class="hljs-section">[ req ]</span><br><span class="hljs-attr">default_bits</span>        = <span class="hljs-number">2048</span><br><span class="hljs-attr">default_md</span>          = sha256<br><span class="hljs-attr">default_keyfile</span>     = privkey.pem<br><span class="hljs-attr">distinguished_name</span>  = req_distinguished_name<br><span class="hljs-attr">attributes</span>          = req_attributes<br><span class="hljs-attr">x509_extensions</span>     = v3_ca<br><span class="hljs-attr">string_mask</span>         = utf8only<br><span class="hljs-section">[ req_distinguished_name ]</span><br><span class="hljs-section">[ req_attributes ]</span><br><span class="hljs-section">[ usr_cert ]</span><br><span class="hljs-attr">basicConstraints</span>       = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">nsComment</span>              = <span class="hljs-string">&quot;OpenSSL Generated Certificate&quot;</span><br><span class="hljs-attr">subjectKeyIdentifier</span>   = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-section">[ v3_ca ]</span><br><span class="hljs-attr">subjectKeyIdentifier</span>   = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid:always,issuer<br><span class="hljs-attr">basicConstraints</span>       = CA:<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="2-2-生成-CA"><a href="#2-2-生成-CA" class="headerlink" title="2.2 生成 CA"></a>2.2 生成 CA</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -out ca.key 2048<br>openssl req -x509 -new -nodes -key ca.key -subj <span class="hljs-string">&quot;/CN=example.ca.com&quot;</span> -days 5000 -out ca.crt<br></code></pre></td></tr></table></figure><h2 id="2-3-生成服务端证书"><a href="#2-3-生成服务端证书" class="headerlink" title="2.3 生成服务端证书"></a>2.3 生成服务端证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -out server.key 2048<br><br>openssl req -new -sha256 -key server.key \<br>    -subj <span class="hljs-string">&quot;/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=server.com&quot;</span> \<br>    -reqexts SAN \<br>    -config &lt;(<span class="hljs-built_in">cat</span> my-openssl.cnf &lt;(<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n[SAN]\nsubjectAltName=DNS:localhost,IP: 你的服务端公网ip,DNS:example.server.com&quot;</span>)) \<br>    -out server.csr<br><br>openssl x509 -req -days 5000 -sha256 \<br>-<span class="hljs-keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \<br>-extfile &lt;(<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;subjectAltName=DNS:localhost,IP: 你的服务端公网ip,DNS:example.server.com&quot;</span>) \<br>-out server.crt<br></code></pre></td></tr></table></figure><blockquote><p>将 <code>subjectAltName</code> 中的 IP 地址改为服务端的公网 IP，否则客户端连接时会报如下错误：</p><p>[W] [service.go:133] login to server failed: tls: failed to verify certificate: x509: certificate is valid for 127.0.0.1, not x.x.x.x</p><p>如果需要绑定域名，将 <code>example.server.com</code> 改为域名。</p></blockquote><h2 id="2-4-生成客户端证书"><a href="#2-4-生成客户端证书" class="headerlink" title="2.4 生成客户端证书"></a>2.4 生成客户端证书</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -out client.key 2048<br><br>openssl req -new -sha256 -key client.key \<br>    -subj <span class="hljs-string">&quot;/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=client.com&quot;</span> \<br>    -reqexts SAN \<br>    -config &lt;(<span class="hljs-built_in">cat</span> my-openssl.cnf &lt;(<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n[SAN]\nsubjectAltName=DNS:client.com,DNS:example.client.com&quot;</span>)) \<br>    -out client.csr<br><br>openssl x509 -req -days 5000 -sha256 \<br>    -<span class="hljs-keyword">in</span> client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \<br>-extfile &lt;(<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;subjectAltName=DNS:client.com,DNS:example.client.com&quot;</span>) \<br>-out client.crt<br></code></pre></td></tr></table></figure><h2 id="2-5-文件使用说明"><a href="#2-5-文件使用说明" class="headerlink" title="2.5 文件使用说明"></a>2.5 文件使用说明</h2><p>最终文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── ca.crt<br>├── ca.key<br>├── ca.srl<br>├── client.crt<br>├── client.csr<br>├── client.key<br>├── my-openssl.cnf<br>├── server.crt<br>├── server.csr<br>└── server.key<br><br>1 directory, 8 file<br></code></pre></td></tr></table></figure><p>需要上传到服务端的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── ca.crt<br>├── server.crt<br>└── server.key<br></code></pre></td></tr></table></figure><p>需要上传到客户端的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── ca.crt<br>├── client.crt<br>└── client.key<br></code></pre></td></tr></table></figure><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h1><p>内网待访问设备（受控端）和本地设备（控制端）都需要启动 frpc 客户端，且需要使用不同的启动配置。</p><h2 id="3-1-解压缩"><a href="#3-1-解压缩" class="headerlink" title="3.1 解压缩"></a>3.1 解压缩</h2><p>解压下载的压缩包，Linux 通过命令<code>tar -zxvf 包名.tar.gz</code>，Windows 直接通过解压软件解压 zip 包。</p><p>将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。</p><h2 id="3-2-编写配置文件"><a href="#3-2-编写配置文件" class="headerlink" title="3.2 编写配置文件"></a>3.2 编写配置文件</h2><h3 id="3-2-1-启动服务端"><a href="#3-2-1-启动服务端" class="headerlink" title="3.2.1 启动服务端"></a>3.2.1 启动服务端</h3><p>配置文件示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frps.toml</span><br><span class="hljs-comment"># frp 监听的端口，默认是7000，可以改成其他的</span><br><span class="hljs-attr">bindPort</span> = <span class="hljs-number">7000</span><br><span class="hljs-comment"># 授权方式，默认为token</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><span class="hljs-comment"># 授权码，请改成更复杂的</span><br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;aaaaa&quot;</span><br><br><span class="hljs-comment"># frp HTTPS TLS配置，按需配置</span><br><span class="hljs-attr">transport.tls.certFile</span> = <span class="hljs-string">&quot;/path/to/server.crt&quot;</span><br><span class="hljs-attr">transport.tls.keyFile</span> = <span class="hljs-string">&quot;/path/to/server.key&quot;</span><br><span class="hljs-attr">transport.tls.trustedCaFile</span> = <span class="hljs-string">&quot;/path/to/ca.crt&quot;</span><br><br><span class="hljs-comment"># frp 日志配置，按需配置</span><br><span class="hljs-attr">log.to</span> = <span class="hljs-string">&quot;/path/to/frps.log&quot;</span><br><span class="hljs-attr">log.level</span> = <span class="hljs-string">&quot;info&quot;</span><br><span class="hljs-attr">log.maxDays</span> = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>配置并保存后，在当前目录下输入启动命令 <code>./frps -c ./frps.toml</code> 启动服务端，查看日志文件，检查是否包含类似输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2024/12/08 13:47:45 [I] [root.go:204] Start frps success<br></code></pre></td></tr></table></figure><h3 id="3-2-2-启动客户端"><a href="#3-2-2-启动客户端" class="headerlink" title="3.2.2 启动客户端"></a>3.2.2 启动客户端</h3><h4 id="3-2-2-1-启动受控端（内网服务器）"><a href="#3-2-2-1-启动受控端（内网服务器）" class="headerlink" title="3.2.2.1 启动受控端（内网服务器）"></a>3.2.2.1 启动受控端（内网服务器）</h4><p>配置文件示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frpc.toml</span><br><span class="hljs-comment"># 服务器公网 IP</span><br><span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;1.1.1.1&quot;</span><br><span class="hljs-comment"># frp 监听的端口，与服务端一致</span><br><span class="hljs-attr">serverPort</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-comment"># 客户端用户名，用于后续权限管理</span><br><span class="hljs-attr">user</span> = <span class="hljs-string">&quot;cli0&quot;</span><br><br><span class="hljs-comment"># 授权方式，默认为token</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><span class="hljs-comment"># 授权码，请改成更复杂的</span><br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;aaaaa&quot;</span><br><br><span class="hljs-comment"># frp HTTPS TLS配置，按需配置</span><br><span class="hljs-attr">transport.tls.certFile</span> = <span class="hljs-string">&quot;/path/to/client.crt&quot;</span><br><span class="hljs-attr">transport.tls.keyFile</span> = <span class="hljs-string">&quot;/path/to/client.key&quot;</span><br><span class="hljs-attr">transport.tls.trustedCaFile</span> = <span class="hljs-string">&quot;/path/to/ca.crt&quot;</span><br><br><span class="hljs-comment"># frp 日志配置，按需配置</span><br><span class="hljs-attr">log.to</span> = <span class="hljs-string">&quot;./frpc.log&quot;</span><br><span class="hljs-attr">log.level</span> = <span class="hljs-string">&quot;info&quot;</span><br><span class="hljs-attr">log.maxDays</span> = <span class="hljs-number">5</span><br><br><span class="hljs-comment"># frp 代理设置</span><br><span class="hljs-section">[[proxies]]</span><br><span class="hljs-comment"># 代理名</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;ssh-stcp&quot;</span><br><span class="hljs-comment"># 代理类型</span><br><span class="hljs-attr">type</span> = <span class="hljs-string">&quot;stcp&quot;</span><br><span class="hljs-comment"># 仅供本代理使用的安全密钥</span><br><span class="hljs-attr">secretKey</span> = <span class="hljs-string">&quot;bbbbb&quot;</span><br><span class="hljs-comment"># 允许控制本节点的控制端用户</span><br><span class="hljs-attr">allowUsers</span> = [<span class="hljs-string">&quot;cli1&quot;</span>, <span class="hljs-string">&quot;cli2&quot;</span>, <span class="hljs-string">&quot;cli3&quot;</span>]<br><span class="hljs-comment"># 代理地址 IP</span><br><span class="hljs-attr">localIP</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-comment"># 需要对外提供服务的端口</span><br><span class="hljs-attr">localPort</span> = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>配置并保存后，在当前目录下输入启动命令 <code>./frpc -c ./frpc.toml</code> 启动客户端，查看日志文件，检查是否包含类似输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2024/12/08 20:58:06 [I] [control.go:143] [ssh] start proxy success<br></code></pre></td></tr></table></figure><h4 id="3-2-2-3-启动控制端（本地客户端）"><a href="#3-2-2-3-启动控制端（本地客户端）" class="headerlink" title="3.2.2.3 启动控制端（本地客户端）"></a>3.2.2.3 启动控制端（本地客户端）</h4><p>配置文件示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frpc.toml</span><br><span class="hljs-comment"># 服务器公网 IP</span><br><span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;1.1.1.1&quot;</span><br><span class="hljs-comment"># frp 监听的端口，与服务端一致</span><br><span class="hljs-attr">serverPort</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-comment"># 客户端用户名，用于后续权限管理</span><br><span class="hljs-attr">user</span> = <span class="hljs-string">&quot;cli1&quot;</span><br><br><span class="hljs-comment"># 授权方式，默认为token</span><br><span class="hljs-attr">auth.method</span> = <span class="hljs-string">&quot;token&quot;</span><br><span class="hljs-comment"># 授权码，请改成更复杂的</span><br><span class="hljs-attr">auth.token</span> = <span class="hljs-string">&quot;aaaaa&quot;</span><br><br><span class="hljs-comment"># frp HTTPS TLS配置，按需配置</span><br><span class="hljs-attr">transport.tls.certFile</span> = <span class="hljs-string">&quot;/path/to/client.crt&quot;</span><br><span class="hljs-attr">transport.tls.keyFile</span> = <span class="hljs-string">&quot;/path/to/client.key&quot;</span><br><span class="hljs-attr">transport.tls.trustedCaFile</span> = <span class="hljs-string">&quot;/path/to/ca.crt&quot;</span><br><br><span class="hljs-comment"># frp 日志配置，按需配置</span><br><span class="hljs-attr">log.to</span> = <span class="hljs-string">&quot;./frpc.log&quot;</span><br><span class="hljs-attr">log.level</span> = <span class="hljs-string">&quot;info&quot;</span><br><span class="hljs-attr">log.maxDays</span> = <span class="hljs-number">5</span><br><br><span class="hljs-comment"># frp 代理设置</span><br><span class="hljs-section">[[visitors]]</span><br><span class="hljs-comment"># 代理名</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;ssh-stcp-vistor&quot;</span><br><span class="hljs-comment"># 代理类型</span><br><span class="hljs-attr">type</span> = <span class="hljs-string">&quot;stcp&quot;</span><br><span class="hljs-comment"># 目标连接的受控端用户名</span><br><span class="hljs-attr">serverUser</span> = <span class="hljs-string">&quot;cli0&quot;</span><br><span class="hljs-comment"># 目标连接的受控端代理名</span><br><span class="hljs-attr">serverName</span> = <span class="hljs-string">&quot;ssh-stcp&quot;</span><br><span class="hljs-comment"># 仅供与目标连接的受控端代理匹配的安全密钥</span><br><span class="hljs-attr">secretKey</span> = <span class="hljs-string">&quot;bbbbb&quot;</span><br><span class="hljs-comment"># visitor 监听的本地地址，通过访问监听的地址和端口，连接到远端代理的服务。</span><br><span class="hljs-attr">bindAddr</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br><span class="hljs-comment"># visitor 监听的本地端口</span><br><span class="hljs-attr">bindPort</span> = <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>配置并保存后，在当前目录下输入启动命令 <code>./frpc -c ./frpc.toml</code> 启动客户端，查看日志文件，检查是否包含类似输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2024/12/08 20:58:06 [I] [control.go:143] [ssh] start proxy success<br></code></pre></td></tr></table></figure><h1 id="4-开机自启动设置"><a href="#4-开机自启动设置" class="headerlink" title="4 开机自启动设置"></a>4 开机自启动设置</h1><p>在 Linux 系统下，使用 systemd 可以方便地控制 frp 服务端 frps 的启动和停止、配置后台运行和开启自启。</p><h2 id="4-1-服务端"><a href="#4-1-服务端" class="headerlink" title="4.1 服务端"></a>4.1 服务端</h2><p>使用文本编辑器，如 vim 创建并编辑 frps.service ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/frps.service<br></code></pre></td></tr></table></figure><p>写入内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-comment"># 服务名称，可自定义</span><br><span class="hljs-attr">Description</span> = frp server<br><span class="hljs-attr">After</span> = network.target syslog.target<br><span class="hljs-attr">Wants</span> = network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span> = simple<br><span class="hljs-comment"># 启动frps的命令</span><br><span class="hljs-attr">ExecStart</span> = /path/to/frps -c /path/to/frps.toml<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span> = multi-user.target<br></code></pre></td></tr></table></figure><h3 id="管理-frps"><a href="#管理-frps" class="headerlink" title="管理 frps"></a>管理 frps</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动frp</span><br>systemctl start frps <span class="hljs-comment"># frps就是您上面创建的文件名</span><br><span class="hljs-comment"># 停止frp</span><br>systemctl stop frps<br><span class="hljs-comment"># 重启frp</span><br>systemctl restart frps<br><span class="hljs-comment"># 查看frp状态</span><br>systemctl status frps<br></code></pre></td></tr></table></figure><h3 id="配置-frps-开机自启"><a href="#配置-frps-开机自启" class="headerlink" title="配置 frps 开机自启"></a>配置 frps 开机自启</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> frps<br></code></pre></td></tr></table></figure><h2 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h2><p>使用文本编辑器，如 vim 创建并编辑 frpc.service ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/frpc.service<br></code></pre></td></tr></table></figure><p>写入内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-comment"># 服务名称，可自定义</span><br><span class="hljs-attr">Description</span> = frp client<br><span class="hljs-attr">After</span> = network.target syslog.target<br><span class="hljs-attr">Wants</span> = network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span> = simple<br><span class="hljs-comment"># 启动frps的命令</span><br><span class="hljs-attr">ExecStart</span> = /path/to/frpc -c /path/to/frpc.toml<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span> = multi-user.target<br></code></pre></td></tr></table></figure><h3 id="管理-frpc"><a href="#管理-frpc" class="headerlink" title="管理 frpc"></a>管理 frpc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动frp</span><br>systemctl start frpc <span class="hljs-comment"># frpc就是您上面创建的文件名</span><br><span class="hljs-comment"># 停止frp</span><br>systemctl stop frpc<br><span class="hljs-comment"># 重启frp</span><br>systemctl restart frpc<br><span class="hljs-comment"># 查看frp状态</span><br>systemctl status frpc<br></code></pre></td></tr></table></figure><h3 id="配置-frpc-开机自启"><a href="#配置-frpc-开机自启" class="headerlink" title="配置 frpc 开机自启"></a>配置 frpc 开机自启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> frpc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
      <tag>Systemd service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 块层编程指南</title>
    <link href="/posts/43eef8dd/"/>
    <url>/posts/43eef8dd/</url>
    
    <content type="html"><![CDATA[<h1 id="1-存储栈IO路径简介"><a href="#1-存储栈IO路径简介" class="headerlink" title="1 存储栈IO路径简介"></a>1 存储栈IO路径简介</h1><p>当使用 read() 和 write() 系统调用向内核提交I&#x2F;O请求后，要历经多个层次才能完整执行。简单来说，一般包括了以下流程：</p><ol><li>首先，经过虚拟文件系统。虚拟文件系统提供了统一的文件和文件系统的相关接口，屏蔽了不同文件系统的差异和操作细节；</li><li>其次，经过适配当前磁盘分区的文件系统。常见文件系统包括了EXT2&#x2F;3&#x2F;4、FATFS等；</li><li>然后，经过通用块层。块层会将I&#x2F;O请求根据需求进行切分和合并等处理，并交给调度层进行请求调度。处理完成后会将I&#x2F;O请求下发给驱动程序继续进行操作；</li><li>最后，经过驱动程序。驱动根据总线协议将请求转换为对应格式的命令。</li></ol><p>通常，应用程序通过系统调用的方式发送I&#x2F;O相关命令到虚拟文件系统。而具体的文件系统在实现上有很大区别，难以用一篇文章简单的概括。本文重点关注I&#x2F;O请求在通用块层及其之下的层次中是怎样被处理的。</p><p>本文以Linux kernel 5.10版本为例，从关键字段出发，通过介绍几个关键函数，着重分析I&#x2F;O处理过程中的数据传递流程。此外，介绍相关字段的定义方式，为块层和驱动开发提供一份编程指南。</p><p><img src="/img/iopath/iopath.png"></p><h1 id="2-I-x2F-O请求的创建和下发"><a href="#2-I-x2F-O请求的创建和下发" class="headerlink" title="2 I&#x2F;O请求的创建和下发"></a>2 I&#x2F;O请求的创建和下发</h1><p>开始前，先给出一个IO请求创建和下发过程的调用栈样例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">sumbit_bio_noacct(struct bio * bio)<br>    ↓<br>__submit_bio_nocacct_mq(struct bio * bio)<br>    ↓<br>blk_mq_submit_bio(struct bio * bio)<br>    ↓<br>blk_mq_try_issue_directly(struct blk_mq_hw_ctx *hctx, struct request *rq, blk_qc_t *cookie)<br>    ↓<br>__blk_mq_try_issue_directly(struct blk_mq_hw_ctx *hctx, struct request *rq, blk_qc_t *cookie, bool bypass_insert, bool last)<br>    ↓<br>__blk_mq_issue_directly(struct blk_mq_hw_ctx *hctx, struct request *rq, blk_qc_t *cookie)<br>    ↓<br>nvme_queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data *bd)<br>    ↓<br>nvme_submit_cmd(struct nvme_queue *nvmeq, struct nvme_command *cmd, bool write_sq)<br>    ↓<br>nvme_write_sq_db(nvmeq, write_sq)<br></code></pre></td></tr></table></figure><h2 id="2-1-bio"><a href="#2-1-bio" class="headerlink" title="2.1 bio"></a>2.1 bio</h2><p>bio结构体是块设备I&#x2F;O的基础单元，它描述了一次I&#x2F;O操作。一个bio结构体包含了需要被读写的数据块、数据缓冲区的指针等信息。</p><h3 id="2-1-1-bio的创建"><a href="#2-1-1-bio的创建" class="headerlink" title="2.1.1 bio的创建"></a>2.1.1 bio的创建</h3><p>通常，bio来自上层文件系统，由文件系统负责创建和初始化等工作。然而，在块层开发工作中，特别是基于Device Mapper机制进行开发时，会遇到创建新的bio结构体来承载命令的需求。本小节介绍两种常用的bio创建方式。</p><p><strong>bio clone</strong></p><p><code>bio_clone_fast</code>函数用于克隆一个现有的bio结构体。常用于对bio进行重用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// struct bio_set bs;</span><br><span class="hljs-comment">// bioset_init(&amp;bs, NUMBER, 0, BIOSET_NEED_BVECS)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">clone</span> =</span> bio_clone_fast(bio, GFP_NOIO, &amp;bs);<br></code></pre></td></tr></table></figure><p><strong>bio alloc</strong></p><p><code>bio_alloc</code>函数用于创建一个新的bio结构体，并为其分配所需的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">b</span>  =</span> bio_alloc(GFP_KERNEL, <span class="hljs-number">1</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> alloc_page(GFP_KERNEL);<br>bio_add_page(read_bio, page, PAGE_SIZE, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>创建完成后，还要根据需求，对bio的各个字段进行相应设置。以下是一个简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> *<span class="hljs-title">bio</span>;</span><br>bio-&gt;bi_opf = REQ_OP_KV_RETRIEVE | REQ_NOMERGE;<br><span class="hljs-comment">// void my_end_io(struct bio *bio);</span><br>bio-&gt;bi_end_io = my_end_io;<br><span class="hljs-comment">// sturct xxx_config *private_data;</span><br>bio-&gt;bi_private = private_data;<br><span class="hljs-comment">// struct block_device *bdev</span><br>bio_set_dev(bio, bdev);<br></code></pre></td></tr></table></figure><h3 id="2-1-2-bio的下发"><a href="#2-1-2-bio的下发" class="headerlink" title="2.1.2 bio的下发"></a>2.1.2 bio的下发</h3><p>下发请求的同时更新统计信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sumbit_bio(bio);<br></code></pre></td></tr></table></figure><p>下发请求的同时更新不统计信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sumbit_bio_noacct(bio);<br></code></pre></td></tr></table></figure><h2 id="2-2-request"><a href="#2-2-request" class="headerlink" title="2.2 request"></a>2.2 request</h2><p>request 结构体是I&#x2F;O请求的更高级表示，它通常包含一个或多个bio 结构体。同一request中的bio一般具有相似的特征，如具有相同的写入提示（write hint）等。从bio到request的过程中，需要根据bio中的相应字段来设置request的字段。</p><h3 id="2-2-1-request的创建"><a href="#2-2-1-request的创建" class="headerlink" title="2.2.1 request的创建"></a>2.2.1 request的创建</h3><p><strong>blk_mq_alloc_request</strong></p><p>通过此函数可申请一个新的request。一般情况下，bio提交后的处理函数会自行创建和分配request。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// struct request_queue *q;</span><br><span class="hljs-comment">// unsigned int op;</span><br><span class="hljs-comment">// blk_mq_req_flags_t flags;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">req</span> =</span> blk_mq_alloc_request(q, op, flags);<br></code></pre></td></tr></table></figure><p><strong>blk_mq_submit_bio</strong></p><p>此函数会调用<code>__blk_mq_alloc_request</code>函数创建request</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// struct request_queue *q = bio-&gt;bi_disk-&gt;queue;</span><br><span class="hljs-comment">// struct blk_mq_alloc_data data = &#123;.q= q,&#125;;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span> =</span> __blk_mq_alloc_request(&amp;data);<br></code></pre></td></tr></table></figure><p>通常，在对bio进行定制化修改（如添加新字段后），如果需要更快地在底层使用这些字段，可以在request中添加相应的字段，并进行相应赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// static void blk_mq_bio_to_request(struct request *rq, struct bio *bio, unsigned int nr_segs)</span><br>rq-&gt;new_value = bio-&gt;newvalue;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-request的下发"><a href="#2-2-2-request的下发" class="headerlink" title="2.2.2 request的下发"></a>2.2.2 request的下发</h3><p>如不涉及I&#x2F;O调度相关的工作，此部分仅作了解即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">blk_mq_try_issue_directly(data.hctx, rq, &amp;cookie);<br></code></pre></td></tr></table></figure><h2 id="2-3-NVMe-command"><a href="#2-3-NVMe-command" class="headerlink" title="2.3 NVMe command"></a>2.3 NVMe command</h2><p>NVMe（Non-Volatile Memory Express）是一种用于访问非易失性存储介质（如SSD）的传输协议。</p><h3 id="2-3-1-NVMe-command的创建"><a href="#2-3-1-NVMe-command的创建" class="headerlink" title="2.3.1 NVMe command的创建"></a>2.3.1 NVMe command的创建</h3><p>NVMe command是一种固定长度的命令格式。命令的解析方式根据需求不同可以自行定义，但单个命令的大小必须为64B。这是它与request和bio的一个重要的区别。</p><p><strong>nvme_queue_rq</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_command</span> <span class="hljs-title">cmnd</span>;</span><br></code></pre></td></tr></table></figure><p>创建完成后，同样的需要进行相应字段的赋值。注意：如果在上层添加了新字段，需要认真分析每一个命令的保留字段，从中选择合适的接收新字段的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// blk_status_t nvme_setup_cmd(struct nvme_ns *ns, struct request *req, struct nvme_command *cmd)</span><br><span class="hljs-comment">// enum nvme_opcode op;</span><br>cmd-&gt;common.opcode = op;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-NVMe-command的下发"><a href="#2-3-2-NVMe-command的下发" class="headerlink" title="2.3.2 NVMe command的下发"></a>2.3.2 NVMe command的下发</h3><p>NVMe command提交到固态盘的过程与固态盘所采用的协议有关。具体细节一般无需关注。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">nvme_submit_cmd(nvmeq, &amp;cmnd, bd-&gt;last);<br></code></pre></td></tr></table></figure><h1 id="3-SSD内的IO处理"><a href="#3-SSD内的IO处理" class="headerlink" title="3 SSD内的IO处理"></a>3 SSD内的IO处理</h1><p>SSD（固态硬盘）作为一种主动设备，其性能提升的一大关键在于使用了提交队列（SQ）和完成队列（CQ）机制。这些机制在NVMe（Non-Volatile Memory Express）协议中得到了广泛应用，是现代高性能存储设备的核心技术之一。</p><h2 id="3-1-提交队列（SQ）和完成队列（CQ）的工作机制"><a href="#3-1-提交队列（SQ）和完成队列（CQ）的工作机制" class="headerlink" title="3.1 提交队列（SQ）和完成队列（CQ）的工作机制"></a>3.1 提交队列（SQ）和完成队列（CQ）的工作机制</h2><h3 id="3-1-1-提交队列（Submission-Queue，SQ）"><a href="#3-1-1-提交队列（Submission-Queue，SQ）" class="headerlink" title="3.1.1 提交队列（Submission Queue，SQ）"></a>3.1.1 提交队列（Submission Queue，SQ）</h3><p>提交队列是主机向SSD提交I&#x2F;O请求的地方。每个提交队列都是一个环形缓冲区，存储着待执行的命令。以下是SQ的工作机制：</p><ol><li><p>命令提交：</p><ul><li>主机将I&#x2F;O命令（如读或写命令）写入提交队列。</li><li>每个命令包含了操作的类型、目标地址、数据长度等信息。</li><li>主机更新提交队列的尾指针（Tail Pointer），指向新的命令位置。</li></ul></li><li><p>命令传递：</p><ul><li>主机通过DMA（Direct Memory Access，直接内存访问）将提交队列中的命令传递给SSD。</li><li>NVMe控制器轮询或中断方式检测到提交队列的变化，读取新命令进行处理。</li></ul></li></ol><h3 id="3-1-2-完成队列（Completion-Queue，CQ）"><a href="#3-1-2-完成队列（Completion-Queue，CQ）" class="headerlink" title="3.1.2 完成队列（Completion Queue，CQ）"></a>3.1.2 完成队列（Completion Queue，CQ）</h3><p>完成队列是SSD向主机报告已完成的I&#x2F;O请求的地方。每个完成队列也是一个环形缓冲区，存储着命令完成的信息。以下是CQ的工作机制：</p><ol><li><p>命令完成：</p><ul><li>SSD处理完一个命令后，将命令的完成信息写入完成队列。</li><li>每条完成信息包含了命令的标识符、执行状态等信息。</li><li>SSD更新完成队列的尾指针，指向新的完成信息位置。</li></ul></li><li><p>命令返回：</p><ul><li>主机通过DMA读取完成队列中的完成信息。</li><li>主机更新完成队列的头指针（Head Pointer），标识已处理的完成信息。</li><li>主机根据完成信息，执行相应的回调函数或处理后续操作。</li></ul></li></ol><h1 id="4-I-x2F-O请求的返回和结束"><a href="#4-I-x2F-O请求的返回和结束" class="headerlink" title="4 I&#x2F;O请求的返回和结束"></a>4 I&#x2F;O请求的返回和结束</h1><p>开始前，先给出一个IO请求返回和结束过程的调用栈样例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvme_process_cq(struct nvme_queue *nvmeq)<br>    ↓<br>nvme_handle_cqe(struct nvme_queue *nvmeq, u16 idx)<br>    ↓<br>nvme_pci_complete_rq(struct request *req)<br>    ↓<br>nvme_complete_rq(struct request *req)<br>    ↓<br>nvme_end_req(struct request *req)<br>    ↓<br>blk_mq_end_request(struct request *rq, blk_status_t error)<br>    ↓<br>__blk_update_request(struct request *req, blk_status_t error,unsigned int nr_bytes)<br>    ↓<br>req_bio_endio(struct request *rq, struct bio *bio, unsigned int nbytes, blk_status_t error)<br>    ↓<br>bio_endio(struct bio *bio);<br></code></pre></td></tr></table></figure><h2 id="4-1-NVMe-command"><a href="#4-1-NVMe-command" class="headerlink" title="4.1 NVMe command"></a>4.1 NVMe command</h2><h2 id="4-1-1-NVMe-command的返回"><a href="#4-1-1-NVMe-command的返回" class="headerlink" title="4.1.1 NVMe command的返回"></a>4.1.1 NVMe command的返回</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_completion</span> *<span class="hljs-title">cqe</span> =</span> &amp;nvmeq-&gt;cqes[idx];<br></code></pre></td></tr></table></figure><h2 id="4-1-2-NVMe-command的结束"><a href="#4-1-2-NVMe-command的结束" class="headerlink" title="4.1.2 NVMe command的结束"></a>4.1.2 NVMe command的结束</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">nvme_complete_rq(<span class="hljs-keyword">struct</span> request *req)<br></code></pre></td></tr></table></figure><h2 id="4-2-request"><a href="#4-2-request" class="headerlink" title="4.2 request"></a>4.2 request</h2><h3 id="4-2-1-request的返回"><a href="#4-2-1-request的返回" class="headerlink" title="4.2.1 request的返回"></a>4.2.1 request的返回</h3><p>request需要接收cqe中附加的请求执行结果相关信息。如果需要在返回结果中传递特定信息（如ZNS append命令需要返回的实际LBA信息），需要在<code>nvme_end_req</code>函数中进行相应的赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">req-&gt;result = le32_to_cpu(nvme_req(req)-&gt;result.u32)<br></code></pre></td></tr></table></figure><h3 id="4-2-2-Request的结束"><a href="#4-2-2-Request的结束" class="headerlink" title="4.2.2 Request的结束"></a>4.2.2 Request的结束</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">req_bio_endio(req, bio, bio_bytes, error);<br></code></pre></td></tr></table></figure><h2 id="4-3-bio"><a href="#4-3-bio" class="headerlink" title="4.3 bio"></a>4.3 bio</h2><h3 id="4-3-1-bio的返回"><a href="#4-3-1-bio的返回" class="headerlink" title="4.3.1 bio的返回"></a>4.3.1 bio的返回</h3><p>同样的，bio需要接收来自request的命令执行相关信息。相关信息在<code>req_bio_endio</code>函数中进行相应的赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bio-&gt;bi_result = rq-&gt;result;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-bio的结束"><a href="#4-3-2-bio的结束" class="headerlink" title="4.3.2 bio的结束"></a>4.3.2 bio的结束</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bio_endio(bio);<br></code></pre></td></tr></table></figure><h1 id="5-如何添加一个新的I-x2F-O路径"><a href="#5-如何添加一个新的I-x2F-O路径" class="headerlink" title="5 如何添加一个新的I&#x2F;O路径"></a>5 如何添加一个新的I&#x2F;O路径</h1><p>添加一个新的I&#x2F;O路径主要包含两个任务：一是新命令和新字段的定义，二是上面提到的新字段值的传递。以下是一个需要修改的结构体的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/blk_types.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> &#123;</span><br>    ···<br>    <span class="hljs-type">int</span> new_value;<br>    ···<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">req_opf</span> &#123;</span><br>    ···<br>    REQ_NEW_OP = <span class="hljs-number">100</span>,<br>    ···<br>&#125;<br><br><span class="hljs-comment">// include/linux/blkdev.h</span><br><span class="hljs-keyword">struct</span> request &#123;<br>    ···<br>    <span class="hljs-type">int</span> new_value;<br>    ···<br>&#125;<br><br><span class="hljs-comment">// inlude/linux/nvme.h</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">nvme_opcode</span> &#123;</span><br>    ···<br>    nvme_new_op = <span class="hljs-number">100</span>,<br>    ···<br>&#125;<br><br><span class="hljs-keyword">struct</span> nvme_command &#123;<br>    ···<br>    <span class="hljs-keyword">struct</span> nvme_new_command new;<br>    ···<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_new_command</span> &#123;</span><br>  __u8    opcde;<br>  __u8    flags;<br>  __u16   command_id;<br>  __le32  nsid;<br>  __u64   rsvd;<br>  __le32  offset;<br>  __u32   rsvd2;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">nvme_data_ptr</span> <span class="hljs-title">dptr</span>;</span> <span class="hljs-comment">/* value dptr prp1,2 */</span><br>  __le32  value_len;        <span class="hljs-comment">/* size in word */</span><br>  __u8    key_len;          <span class="hljs-comment">/* 0 ~ 255 (keylen - 1) */</span><br>  __u8    option;<br>  __u8    invalid_byte:<span class="hljs-number">2</span>;<br>  __u8    rsvd3:<span class="hljs-number">6</span>;<br>  __u8    rsvd4;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      <span class="hljs-type">char</span>    key[<span class="hljs-number">16</span>];<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      __le64  key_prp;<br>      __le64  key_prp2;<br>    &#125;;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>bio</tag>
      
      <tag>driver</tag>
      
      <tag>NVMe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Kernel Debug 配置教程</title>
    <link href="/posts/c45bcc25/"/>
    <url>/posts/c45bcc25/</url>
    
    <content type="html"><![CDATA[<p>本文记录了在基于 Qemu 的虚拟机中进行内核代码调试的完整流程。</p><h1 id="1-编译安装调试版内核"><a href="#1-编译安装调试版内核" class="headerlink" title="1 编译安装调试版内核"></a>1 编译安装调试版内核</h1><p>内核编译的完整流程可参考<a href="/posts/3473f5e6/" title="Linux内核编译">Linux内核编译</a>。</p><p>在开始编译之前，需要对<code>.config</code>进行简单修改以关闭或打开特定的配置项。推荐使用<code>make menuconfig</code>命令进行配置。其余的编译流程不变。</p><h2 id="1-1-必须打开的配置"><a href="#1-1-必须打开的配置" class="headerlink" title="1.1 必须打开的配置"></a>1.1 必须打开的配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Kernel hacking  ---&gt;<br>    [*] Kernel debugging<br>    Compile-time checks and compiler options  ---&gt;<br>        [*] Compile the kernel with debug info<br>        [*]   Provide GDB scripts <span class="hljs-keyword">for</span> kernel debugging<br></code></pre></td></tr></table></figure><h2 id="1-2-必须关闭的配置"><a href="#1-2-必须关闭的配置" class="headerlink" title="1.2 必须关闭的配置"></a>1.2 必须关闭的配置</h2><p>下面的选项会导致打断点失败，一定要关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Processor <span class="hljs-built_in">type</span> and features ----&gt;<br>[] Randomize the address of the kernel image (KASLR)<br></code></pre></td></tr></table></figure><h1 id="2-启动内核并调试"><a href="#2-启动内核并调试" class="headerlink" title="2 启动内核并调试"></a>2 启动内核并调试</h1><h2 id="2-1-内核启动"><a href="#2-1-内核启动" class="headerlink" title="2.1 内核启动"></a>2.1 内核启动</h2><p>为了启动内核以及 GDB Server，需要在 Qemu 虚拟机的启动命令中加入两个新参数<code>-s -S</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-x86_64 -s -S ……<br></code></pre></td></tr></table></figure><blockquote><p><code>-s</code> 选项是 -gdb 的简写，会在本地的 1234 端口启动一个 GDB 服务。<br><code>-S</code> 代表暂停虚拟机，等待 GDB 执行 continue 指令。其余参数不变。</p></blockquote><h2 id="2-2-内核调试"><a href="#2-2-内核调试" class="headerlink" title="2.2 内核调试"></a>2.2 内核调试</h2><h3 id="2-2-1-VS-Code-图形化界面调试"><a href="#2-2-1-VS-Code-图形化界面调试" class="headerlink" title="2.2.1 VS Code 图形化界面调试"></a>2.2.1 VS Code 图形化界面调试</h3><p>VS Code 调试功能配置可参考<a href="/posts/b3d38a78/" title="VS Code配置教程">VS Code配置教程</a>。</p><p>在<code>.vscode/launch.json</code>文件中，需要将被调试的程序指定为<code>vmlinux</code>，其他字段无需修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>/vmlinux&quot;</span>,<br></code></pre></td></tr></table></figure><blockquote><ol><li>虚拟机开机阶段不能打断点，需要等内核加载完毕才可设置断点</li><li>如需调试内核模块代码，简单起见，需要将内核模块编译到内核中（而非单独的模块）</li></ol></blockquote><h3 id="2-2-1-GDB-命令行界面调试"><a href="#2-2-1-GDB-命令行界面调试" class="headerlink" title="2.2.1 GDB 命令行界面调试"></a>2.2.1 GDB 命令行界面调试</h3><p>先加载符号表，然后连接到 Qemu 使用的远程调试端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/linux-5.3.7<br>gdb vmlinux<br>(gdb) target remote :1234<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qemu</tag>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>gdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zotero 配置教程</title>
    <link href="/posts/16413af4/"/>
    <url>/posts/16413af4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装Zotero"><a href="#1-安装Zotero" class="headerlink" title="1 安装Zotero"></a>1 安装Zotero</h1><p>在<a href="https://www.zotero.org/download/">官网</a>下载安装包进行安装，同时可安装<code>Zotero Connector</code>浏览器插件以便于将网页内容保存到Zotero文档库中。</p><p>Zotero支持同步功能，需要注册账号使用。</p><h1 id="2-安装插件"><a href="#2-安装插件" class="headerlink" title="2 安装插件"></a>2 安装插件</h1><h2 id="2-1-Tara"><a href="#2-1-Tara" class="headerlink" title="2.1 Tara"></a>2.1 Tara</h2><p>用于备份和恢复首选项、插件、翻译器和样式。可以在不同设备之间保持相同的设置，也可以从备份中恢复历史记录设置。</p><p><a href="https://github.com/l0o0/tara">下载地址</a></p><h2 id="2-2-Actions-and-Tags-for-Zotero"><a href="#2-2-Actions-and-Tags-for-Zotero" class="headerlink" title="2.2 Actions and Tags for Zotero"></a>2.2 Actions and Tags for Zotero</h2><p>AT可以用于：</p><ul><li>使用操作自动标记项目，由Zotero事件或用户定义的快捷方式触发</li><li>使用自定义脚本自动化您的工作流程！<ul><li>替换标记</li><li>复制项目链接</li><li>打开项目时自动生成备注</li><li>自动翻译新项目的标题&#x2F;摘要</li><li><a href="https://github.com/windingwind/zotero-actions-tags/discussions/categories/action-scripts">了解更多信息→</a></li></ul></li></ul><p><a href="https://github.com/windingwind/zotero-actions-tags">下载地址</a></p><h2 id="2-3-Better-Notes-for-Zotero"><a href="#2-3-Better-Notes-for-Zotero" class="headerlink" title="2.3 Better Notes for Zotero"></a>2.3 Better Notes for Zotero</h2><p>笔记管理的一切功能。</p><p><a href="https://github.com/windingwind/zotero-better-notes">下载地址</a></p><h2 id="2-4-Crush-Reference"><a href="#2-4-Crush-Reference" class="headerlink" title="2.4 Crush Reference"></a>2.4 Crush Reference</h2><p>更好的查看和管理参考文献。</p><p><a href="https://github.com/MuiseDestiny/zotero-reference">下载地址</a></p><h2 id="2-5-Jasminum"><a href="#2-5-Jasminum" class="headerlink" title="2.5 Jasminum"></a>2.5 Jasminum</h2><p>一个简单的Zotero 插件，用于识别中文元数据。</p><p><a href="https://github.com/l0o0/jasminum">下载地址</a></p><h2 id="2-6-Translate-for-Zotero"><a href="#2-6-Translate-for-Zotero" class="headerlink" title="2.6 Translate for Zotero"></a>2.6 Translate for Zotero</h2><p>将PDF、EPub、网页、元数据、注释、笔记翻译成目标语言。支持20多项翻译服务。</p><p><a href="https://github.com/windingwind/zotero-pdf-translate/">下载地址</a></p><h1 id="3-相关资源"><a href="#3-相关资源" class="headerlink" title="3 相关资源"></a>3 相关资源</h1><p><a href="https://zotero-chinese.com/">Zotero中文小组</a><br><a href="https://plugins.zotero-chinese.com/">Zotero插件市场</a></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zoreto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ventoy 指南</title>
    <link href="/posts/9f78099c/"/>
    <url>/posts/9f78099c/</url>
    
    <content type="html"><![CDATA[<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p>Ventoy是一款多ISO启动引导程序，最大的优点就是无需格式化优盘，用户只需要将所需的ISO镜像文件拷贝至优盘中即可在Ventoy界面中选择自己想要的ISO镜像文件。</p><h1 id="软件优势"><a href="#软件优势" class="headerlink" title="软件优势"></a>软件优势</h1><ul><li><p>广泛兼容：支持包括Windows 10、Windows 8.1、Windows 7、WinPE 系统以及Ubuntu等多种Linux发行版。</p></li><li><p>无需格盘：该工具可以直接安装到U盘上且不需要将其他镜像刻录U盘，用户需要做的仅仅是将ISO复制到U盘中。</p></li><li><p>启动兼容：无差别支持Legacy BIOS 和UEFI模式，无论你的电脑主板使用什么模式Ventoy都可以自动检测识别。</p></li><li><p>大型文件：该工具也支持将超过4GB的镜像文件复制到U盘，这点很重要因为Windows 10 镜像文件已超过4GB。</p></li><li><p>其他优势：可并存多个操作系统镜像无需每次使用重新格盘刻录、启动过程中支持写保护、版本升级不丢失数据。</p></li></ul><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p>首先去Ventoy官网下载<a href="https://www.ventoy.net/cn/download.html">安装文件</a>，然后解压缩并执行Ventoy2Disk.exe文件，打开后就能看到Ventoy的主界面，选择好U盘盘符后，直接点击Install即可安装Ventoy。</p><p><img src="/img/ventoy/ventoy.png"></p><p>主界面各部分的含义如下：</p><ul><li>安装包内 Ventoy 版本：当前安装包中的Ventoy版本号</li><li>设备内部 Ventoy 版本：U盘中已安装的Ventoy版本号，如果为空则表示U盘内没有安装Ventoy</li><li>左侧显示的 MBR&#x2F;GPT：用户当前选择的分区格式，可以在选项中修改，只对安装过程有效。</li><li>右侧显示的 MBR&#x2F;GPT：设备当前使用的分区格式 （也就是当初安装Ventoy时选择的分区格式），如果U盘内没有安装Ventoy，则会显示空。</li><li>左侧显示的 exFAT&#x2F;NTFS&#x2F;FAT32：用户当前选择的Ventoy分区文件系统类型，可以在选项中修改，只对安装过程有效。</li><li>右侧显示的 exFAT&#x2F;NTFS&#x2F;FAT32：当前设备中Ventoy分区的文件系统类型。如果当前设备中没有安装Ventoy则显示为空。</li><li>安装：把Ventoy安装到U盘，只有第一次的时候需要，其他情况就只需要升级即可</li><li>升级：升级U盘中的Ventoy版本，升级不会影响已有的ISO文件</li></ul><p>如果Ventoy2Disk.exe安装或升级一直提示失败，请参考<a href="https://www.ventoy.net/cn/doc_ventoy2disk.html">说明</a></p><p>MBR&#x2F;GPT 分区格式选项只在安装时会用，升级的时候是不管的，也就是说升级是不会改变现有分区格式的，必须重新安装才可以。</p><p>安装完之后，U盘存放镜像文件的Ventoy分区也可以再次手动格式化。支持 exFAT&#x2F;FAT32&#x2F;NTFS&#x2F;UDF&#x2F;XFS&#x2F;Ext2&#x2F;3&#x2F;4 系统。对于普通U盘建议使用exFAT文件系统，对于大容量的移动硬盘、本地硬盘、SSD等建议使用NTFS文件系统。</p><h2 id="拷贝镜像文件"><a href="#拷贝镜像文件" class="headerlink" title="拷贝镜像文件"></a>拷贝镜像文件</h2><p>安装完成之后，U盘会被分成两个分区。其中第1个分区（就是容量大的那个分区，也可以称之为镜像分区）将会被格式化为exFAT文件系统（也可以再手动重新格式化成其他支持的文件系统，比如 NTFS&#x2F;FAT32&#x2F;UDF&#x2F;XFS&#x2F;Ext2&#x2F;3&#x2F;4 等），你只需要把ISO&#x2F;WIM等文件拷贝到这里面即可。</p><p>你可以把文件放在任意目录以及子目录下。 Ventoy默认会遍历所有的目录和子目录，找出所有的镜像文件，并按照字母排序之后显示在菜单中。你可以通过插件配置让Ventoy只搜索某一个固定的目录，或是跳过某些特殊目录等。</p><h2 id="升级-Ventoy"><a href="#升级-Ventoy" class="headerlink" title="升级 Ventoy"></a>升级 Ventoy</h2><p>如果Ventoy发布了新版本之后，你可以点击<code>升级</code>按钮进行升级。</p><p>需要说明的是，升级操作是安全的，不会影响现有的镜像文件，也不会重新把镜像分区改成exFAT格式。</p><p>你可以认为升级只是把第二个分区（32MB的VTOYEFI分区）内的Ventoy启动文件覆盖了，不会动到镜像分区，因此镜像文件不会丢失。</p><p>即使你当初安装完成之后，把镜像分区重新格式化为了NTFS，升级的时候也不会再改回exFAT。 </p>]]></content>
    
    
    <categories>
      
      <category>常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ventoy</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos文本模式安装</title>
    <link href="/posts/7d530f04/"/>
    <url>/posts/7d530f04/</url>
    
    <content type="html"><![CDATA[<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h1><h2 id="1-1-创建系统盘"><a href="#1-1-创建系统盘" class="headerlink" title="1.1 创建系统盘"></a>1.1 创建系统盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Download a Ubuntu server ISO file</span><br>sudo apt-get install qemu-system-x86<br><span class="hljs-comment"># Create a QCOW2 disk image</span><br>qemu-img create -f qcow2 femu.qcow2 80G<br></code></pre></td></tr></table></figure><h2 id="1-2-下载镜像"><a href="#1-2-下载镜像" class="headerlink" title="1.2 下载镜像"></a>1.2 下载镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> images &amp;&amp; <span class="hljs-built_in">cd</span> images<br>wget https://mirrors.tuna.tsinghua.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-2009.iso<br></code></pre></td></tr></table></figure><h2 id="1-3-挂载镜像"><a href="#1-3-挂载镜像" class="headerlink" title="1.3 挂载镜像"></a>1.3 挂载镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> centos<br>sudo mount CentOS-7-x86_64-Minimal-2009.iso ./centos -o loop<br><span class="hljs-comment"># find the full path of vmlinuz and initrd</span><br>find ./centos -name <span class="hljs-string">&quot;vmlinuz&quot;</span><br>find ./centos -name <span class="hljs-string">&quot;initrd&quot;</span><br></code></pre></td></tr></table></figure><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><p>在文本模式安装时，由于缺少图形化界面，需要通过实现提取内核并在Qemu启动时进行指定才可以看到文本显示界面。完整的启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo qemu-system-x86_64 -m 1024 -smp 4 -boot d -cpu host -enable-kvm \<br>-hda femu.qcow2 -cdrom CentOS-7-x86_64-Minimal-2009.iso -nographic \<br>-kernel ./centos/images/pxeboot/vmlinuz -initrd ./centos/images/pxeboot/initrd.img -append console=ttyS0<br></code></pre></td></tr></table></figure><p>进入安装过程后按照提示完成各部分设置即可。</p><h1 id="3-启动-amp-配置"><a href="#3-启动-amp-配置" class="headerlink" title="3 启动&amp;配置"></a>3 启动&amp;配置</h1><h2 id="3-1-启动"><a href="#3-1-启动" class="headerlink" title="3.1 启动"></a>3.1 启动</h2><p>安装完成后，使用以下命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo qemu-system-x86_64 -hda femu.qcow2 -net nic -net user -m 4096 -localtime -smp 4 -cpu host -enable-kvm<br></code></pre></td></tr></table></figure><h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><p>第一次进入系统后，系统没有网络，需要进行相应配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dhclient<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>Centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Perf与火焰图</title>
    <link href="/posts/6121d6c0/"/>
    <url>/posts/6121d6c0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装-perf"><a href="#1-安装-perf" class="headerlink" title="1 安装 perf"></a>1 安装 perf</h1><p>perf 命令（performance 的缩写）是 Linux 系统原生提供的性能分析工具，会返回 CPU 正在执行的函数名以及调用栈（stack）。通常，它的执行频率是 99Hz（每秒 99 次），如果 99 次都返回同一个函数名，那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题。</p><h2 id="1-1-使用-apt-安装"><a href="#1-1-使用-apt-安装" class="headerlink" title="1.1 使用 apt 安装"></a>1.1 使用 apt 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install linux-tools-common<br>sudo apt install linux-tools-`<span class="hljs-built_in">uname</span> -r`<br><span class="hljs-comment"># 通过以下命令验证安装是否成功</span><br>perf --version<br></code></pre></td></tr></table></figure><h2 id="1-2-使用源码编译安装"><a href="#1-2-使用源码编译安装" class="headerlink" title="1.2 使用源码编译安装"></a>1.2 使用源码编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查内核版本</span><br><span class="hljs-built_in">uname</span> -r<br><span class="hljs-comment"># 下载内核源码</span><br>wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/linux-4.19.tar.gz<br><span class="hljs-comment"># 安装依赖并解压</span><br>sudo apt install -y build-essential bison flex libssl-dev libelf-dev libcap-dev libattr1-dev libncurses-dev<br>tar -zxvf linux-4.19.tar.gz<br><span class="hljs-built_in">cd</span> linux-4.19/tools/perf/<br><span class="hljs-comment"># 编译安装</span><br>make perf -j8 V=1<br>make perf install DESTDIR=/usr/local V=1<br><span class="hljs-comment"># 通过以下命令验证安装是否成功</span><br>perf --version<br></code></pre></td></tr></table></figure><h1 id="2-使用-perf"><a href="#2-使用-perf" class="headerlink" title="2 使用 perf"></a>2 使用 perf</h1><h2 id="2-1-perf-record"><a href="#2-1-perf-record" class="headerlink" title="2.1 perf record"></a>2.1 perf record</h2><p>perf record 记录单个函数级别的统计信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo perf record -F 99 -p 13204 -g -- <span class="hljs-built_in">sleep</span> 30<br></code></pre></td></tr></table></figure><p>上面的代码中，<code>perf record</code>表示记录，<code>-F 99</code>表示每秒 99 次，<code>-p 13204</code>是进程号，即对哪个进程进行分析，<code>-g</code>表示记录调用栈，<code>sleep 30</code>则是持续 30 秒。</p><p>运行后会产生一个庞大的文本文件。如果一台服务器有 16 个 CPU，每秒抽样 99 次，持续 30 秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。</p><h2 id="2-2-perf-report"><a href="#2-2-perf-report" class="headerlink" title="2.2 perf report"></a>2.2 perf report</h2><p><code>perf report</code>命令可以统计每个调用栈出现的百分比，然后从高到低排列。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo perf report -a --stdio<br></code></pre></td></tr></table></figure><h2 id="2-3-perf-list"><a href="#2-3-perf-list" class="headerlink" title="2.3 perf list"></a>2.3 perf list</h2><p>列出所有能够触发 perf 采样点的事件,主要区分为如下三类事件：</p><ul><li>Hardware Event 是由 PMU 硬件产生的事件，比如 cache 命中</li><li>Software Event 是内核软件产生的事件，比如进程切换，tick 数等</li><li>Tracepoint event 是内核中的静态 tracepoint 所触发的事件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo perf list<br></code></pre></td></tr></table></figure><h2 id="2-4-perf-top"><a href="#2-4-perf-top" class="headerlink" title="2.4 perf top"></a>2.4 perf top</h2><p>用于实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo perf top<br></code></pre></td></tr></table></figure><h2 id="2-5-perf-script"><a href="#2-5-perf-script" class="headerlink" title="2.5 perf script"></a>2.5 perf script</h2><p>Tom Zanussi 将 perl 和 python 解析器嵌入到 perf 程序中，从而使得 perf 能够自动执行 perl 或者 python 脚本进一步进行处理，从而为 perf 提供了强大的扩展能力。因为任何人都可以编写新的脚本，对 perf 的原始输出数据进行所需要的进一步处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo perf script &gt; out.perf<br></code></pre></td></tr></table></figure><h1 id="3-火焰图"><a href="#3-火焰图" class="headerlink" title="3 火焰图"></a>3 火焰图</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>火焰图是基于 perf 结果产生的 SVG 图片，用来展示 CPU 的调用栈。</p><p><img src="/img/perf/flamegraph.svg"></p><p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题。</p><p>可通过 GITHUB 直接下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/brendangregg/FlameGraph.git<br></code></pre></td></tr></table></figure><h2 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/FlameGraph<br><br>perf record -F 99 -a -g -- <span class="hljs-built_in">sleep</span> 60<br>perf script &gt; out.perf<br>./stackcollapse-perf.pl out.perf &gt; out.folded<br>./flamegraph.pl out.kern_folded &gt; kernel.svg<br></code></pre></td></tr></table></figure><p>火焰图是 SVG 图片，可以与用户互动。</p><ul><li><p>鼠标悬浮。火焰的每一层都会标注函数名，鼠标悬浮时会显示完整的函数名、抽样抽中的次数、占据总抽样次数的百分比。</p></li><li><p>点击放大。在某一层点击，火焰图会水平放大，该层会占据所有宽度，显示详细信息。左上角会同时显示”Reset Zoom”，点击该链接，图片就会恢复原样。</p></li><li><p>搜索。按下 Ctrl + F 会显示一个搜索框，用户可以输入关键词或正则表达式，所有符合条件的函数名会高亮显示。</p></li></ul><h1 id="4-范例"><a href="#4-范例" class="headerlink" title="4 范例"></a>4 范例</h1><h2 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf top -e cycles:k <span class="hljs-comment">#显示内核和模块中，消耗最多 CPU 周期的函数</span><br><br>perf top -e kmem:kmem_cache_alloc <span class="hljs-comment">#显示分配高速缓存最多的函数</span><br><br>perf top<br><br>Samples: 1M of event <span class="hljs-string">&#x27;cycles&#x27;</span>, Event count (approx.): 73891391490<br> 5.44% perf [.] 0x0000000000023256<br> 4.86% [kernel] [k] \_spin_lock<br> 2.43% [kernel] [k] \_spin_lock_bh<br> 2.29% [kernel] [k] \_spin_lock_irqsave<br> 1.77% [kernel] [k] **d_lookup<br> 1.55% libc-2.12.so [.] **strcmp_sse42<br> 1.43% nginx [.] ngx_vslprintf<br> 1.37% [kernel] [k] tcp_poll<br><br>第一列：符号引发的性能事件的比例，默认指占用的 cpu 周期比例。<br>第二列：符号所在的 DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。<br>第三列：DSO 的类型。[.]表示此符号属于用户态的 ELF 文件，包括可执行文件与动态链接库)。[k]表述此符号属于内核或模块。<br>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。<br></code></pre></td></tr></table></figure><h2 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf top -g <span class="hljs-comment">#得到调用关系图</span><br><br>perf top -e cycles <span class="hljs-comment">#指定性能事件</span><br><br>perf top -p 23015,32476 <span class="hljs-comment">#查看这两个进程的 cpu cycles 使用情况</span><br><br>perf top -s <span class="hljs-built_in">comm</span>,pid,symbol <span class="hljs-comment">#显示调用 symbol 的进程名和进程号</span><br><br>perf top --comms nginx,top <span class="hljs-comment">#仅显示属于指定进程的符号</span><br><br>perf top --symbols kfree <span class="hljs-comment">#仅显示指定的符号</span><br></code></pre></td></tr></table></figure><h2 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf <span class="hljs-built_in">stat</span> <span class="hljs-built_in">ls</span><br><br>Performance counter stats <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;ls&#x27;</span>:<br><br>          0.653782 task-clock                <span class="hljs-comment">#    0.691 CPUs utilized</span><br>                 0 context-switches          <span class="hljs-comment">#    0.000 K/sec</span><br>                 0 CPU-migrations            <span class="hljs-comment">#    0.000 K/sec</span><br>               247 page-faults               <span class="hljs-comment">#    0.378 M/sec</span><br>         1,625,426 cycles                    <span class="hljs-comment">#    2.486 GHz</span><br>         1,050,293 stalled-cycles-frontend   <span class="hljs-comment">#   64.62% frontend cycles idle</span><br>           838,781 stalled-cycles-backend    <span class="hljs-comment">#   51.60% backend  cycles idle</span><br>         1,055,735 instructions              <span class="hljs-comment">#    0.65  insns per cycle</span><br>                                             <span class="hljs-comment">#    0.99  stalled cycles per insn</span><br>           210,587 branches                  <span class="hljs-comment">#  322.106 M/sec</span><br>            10,809 branch-misses             <span class="hljs-comment">#    5.13% of all branches</span><br><br>       0.000945883 seconds time elapsed<br><br>    输出包括<span class="hljs-built_in">ls</span>的执行时间，以及10个性能事件的统计。<br><br>    task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。<br><br>    context-switches：上下文的切换次数。<br><br>    CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU<br><br>    迁移到另一个CPU。<br><br>    page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内<br><br>    存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配<br><br>    等情况也会触发缺页异常。<br><br>    cycles：消耗的处理器周期数。如果把被<span class="hljs-built_in">ls</span>使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。<br><br>    可以用cycles / task-clock算出。<br><br>    stalled-cycles-frontend：略过。<br><br>    stalled-cycles-backend：略过。<br><br>    instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。<br><br>    branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。<br><br>perf <span class="hljs-built_in">stat</span> -r 10 <span class="hljs-built_in">ls</span> &gt; /dev/null <span class="hljs-comment">#执行 10 次程序，给出标准偏差与期望的比值</span><br><br>perf <span class="hljs-built_in">stat</span> -v <span class="hljs-built_in">ls</span> &gt; /dev/null <span class="hljs-comment">#显示更详细的信息</span><br><br>perf <span class="hljs-built_in">stat</span> -n <span class="hljs-built_in">ls</span> &gt; /dev/null <span class="hljs-comment">#只显示任务执行时间，不显示性能计数器</span><br><br>perf <span class="hljs-built_in">stat</span> -a -A <span class="hljs-built_in">ls</span> &gt; /dev/null <span class="hljs-comment">#单独给出每个 CPU 上的信息</span><br><br>perf <span class="hljs-built_in">stat</span> -e syscalls:sys_enter <span class="hljs-built_in">ls</span> <span class="hljs-comment">#ls 命令执行了多少次系统调用</span><br></code></pre></td></tr></table></figure><h2 id="例-4"><a href="#例-4" class="headerlink" title="例 4"></a>例 4</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf record -p `pgrep -d <span class="hljs-string">&#x27;,&#x27;</span> nginx` <span class="hljs-comment">#记录 nginx 进程的性能数据</span><br><br>perf record <span class="hljs-built_in">ls</span> -g <span class="hljs-comment">#记录执行 ls 时的性能数据</span><br><br>perf record -e syscalls:sys_enter <span class="hljs-built_in">ls</span> <span class="hljs-comment">#记录执行 ls 时的系统调用，可以知道哪些系统调用最频繁</span><br></code></pre></td></tr></table></figure><h2 id="例-5"><a href="#例-5" class="headerlink" title="例 5"></a>例 5</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf lock record <span class="hljs-built_in">ls</span> <span class="hljs-comment">#记录</span><br><br>perf lock report <span class="hljs-comment">#报告</span><br><br>                Name   acquired  contended total <span class="hljs-built_in">wait</span> (ns)   max <span class="hljs-built_in">wait</span> (ns)   min <span class="hljs-built_in">wait</span> (ns)<br><br>&amp;mm-&gt;page*table*... 382 0 0 0 0<br>&amp;mm-&gt;page*table*... 72 0 0 0 0<br>&amp;fs-&gt;lock 64 0 0 0 0<br>dcache_lock 62 0 0 0 0<br>vfsmount_lock 43 0 0 0 0<br>&amp;newf-&gt;file_lock... 41 0 0 0 0<br><br>Name：内核锁的名字。<br>aquired：该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。<br>contended：该锁等待后获得的次数，此时被其它内核路径占用，需要等待。<br>total <span class="hljs-built_in">wait</span>：为了获得该锁，总共的等待时间。<br>max <span class="hljs-built_in">wait</span>：为了获得该锁，最大的等待时间。<br>min <span class="hljs-built_in">wait</span>：为了获得该锁，最小的等待时间。<br></code></pre></td></tr></table></figure><h2 id="例-6"><a href="#例-6" class="headerlink" title="例 6"></a>例 6</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf kmem record <span class="hljs-built_in">ls</span> <span class="hljs-comment">#记录</span><br><br>perf kmem <span class="hljs-built_in">stat</span> --<span class="hljs-built_in">caller</span> --alloc -l 20 <span class="hljs-comment">#报告</span><br><br>---<br><br>Callsite | Total_alloc/Per | Total_req/Per | Hit | Ping-pong | Frag<br><br>perf_event_mmap+ec | 311296/8192 | 155952/4104 | 38 | 0 | 49.902%<br>proc_reg_open+41 | 64/64 | 40/40 | 1 | 0 | 37.500%<br>\_\_kmalloc_node+4d | 1024/1024 | 664/664 | 1 | 0 | 35.156%<br>ext3_readdir+5bd | 64/64 | 48/48 | 1 | 0 | 25.000%<br>load_elf_binary+8ec | 512/512 | 392/392 | 1 | 0 | 23.438%<br><br>Callsite：内核代码中调用 kmalloc 和 kfree 的地方。<br>Total_alloc/Per：总共分配的内存大小，平均每次分配的内存大小。<br>Total_req/Per：总共请求的内存大小，平均每次请求的内存大小。<br>Hit：调用的次数。<br>Ping-pong：kmalloc 和 kfree 不被同一个 CPU 执行时的次数，这会导致 cache 效率降低。<br>Frag：碎片所占的百分比，碎片 = 分配的内存 - 请求的内存，这部分是浪费的。<br>有使用--alloc 选项，还会看到 Alloc Ptr，即所分配内存的地址。<br></code></pre></td></tr></table></figure><h2 id="例-7"><a href="#例-7" class="headerlink" title="例 7"></a>例 7</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf <span class="hljs-built_in">sched</span> record <span class="hljs-built_in">sleep</span> 10<br><br>perf report latency --<span class="hljs-built_in">sort</span> max<br><br>---<br><br>Task | Runtime ms | Switches | Average delay ms | Maximum delay ms | Maximum delay at |<br><br>---<br><br>events/10:61 | 0.655 ms | 10 | avg: 0.045 ms | max: 0.161 ms | max at: 9804.958730 s<br><span class="hljs-built_in">sleep</span>:11156 | 2.263 ms | 4 | avg: 0.052 ms | max: 0.118 ms | max at: 9804.865552 s<br>edac-poller:1125 | 0.598 ms | 10 | avg: 0.042 ms | max: 0.113 ms | max at: 9804.958698 s<br>events/2:53 | 0.676 ms | 10 | avg: 0.037 ms | max: 0.102 ms | max at: 9814.751605 s<br>perf:11155 | 2.109 ms | 1 | avg: 0.068 ms | max: 0.068 ms | max at: 9814.867918 s<br><br>TASK：进程名和 pid。<br>Runtime：实际的运行时间。<br>Switches：进程切换的次数。<br>Average delay：平均的调度延迟。<br>Maximum delay：最大的调度延迟。<br>Maximum delay at：最大调度延迟发生的时刻。<br></code></pre></td></tr></table></figure><h2 id="例-8"><a href="#例-8" class="headerlink" title="例 8"></a>例 8</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf probe --line schedule <span class="hljs-comment">#前面有行号的可以探测，没有行号的就不行了</span><br><br>perf report latency --<span class="hljs-built_in">sort</span> max <span class="hljs-comment">#在 schedule 函数的 12 处增加一个探测点</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>perf</tag>
      
      <tag>flamegraph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frp 配置教程</title>
    <link href="/posts/1c4bcd74/"/>
    <url>/posts/1c4bcd74/</url>
    
    <content type="html"><![CDATA[<h1 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h1><p>frp 采用 Golang 编写，支持跨平台，仅需下载对应平台的二进制文件即可执行，没有额外依赖。</p><p>可以在 Github 的 <a href="https://github.com/fatedier/frp/releases">Release</a> 页面中下载到最新版本的客户端和服务端二进制文件，所有文件被打包在一个压缩包中。</p><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h1><h2 id="2-1-解压缩"><a href="#2-1-解压缩" class="headerlink" title="2.1 解压缩"></a>2.1 解压缩</h2><p>解压下载的压缩包，Linux 通过命令<code>tar -zxvf 包名.tar.gz</code>，Windows 直接通过解压软件解压 zip 包。</p><p>将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。</p><h2 id="2-2-编写配置文件"><a href="#2-2-编写配置文件" class="headerlink" title="2.2 编写配置文件"></a>2.2 编写配置文件</h2><h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>配置文件示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frps.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-comment"># frp监听的端口，默认是7000，可以改成其他的</span><br><span class="hljs-attr">bind_port</span> = ××××<br><span class="hljs-comment"># 授权码，请改成更复杂的</span><br><span class="hljs-attr">token</span> = ××××  <span class="hljs-comment"># 这个token之后在客户端会用到</span><br><br><span class="hljs-comment"># frp管理后台端口，请按自己需求更改</span><br><span class="hljs-attr">dashboard_port</span> = ××××<br><span class="hljs-comment"># frp管理后台用户名和密码，请改成自己的</span><br><span class="hljs-attr">dashboard_user</span> = ××××<br><span class="hljs-attr">dashboard_pwd</span> = ××××<br><span class="hljs-attr">enable_prometheus</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># frp日志配置，按需配置</span><br><span class="hljs-attr">log_file</span> = /var/log/frps.log<br><span class="hljs-attr">log_level</span> = info<br><span class="hljs-attr">log_max_days</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>配置并保存后，在当前目录下输入启动命令 <code>./frps -c ./frps.ini</code> 启动服务端，观察日志文件得到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/11/07 13:47:45 [I] [service.go:124] frps tcp listen on 0.0.0.0:7070<br>2022/11/07 13:47:45 [I] [service.go:166] http service listen on 0.0.0.0:8081<br>2022/11/07 13:47:45 [I] [root.go:204] Start frps success<br></code></pre></td></tr></table></figure><h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><p>配置文件示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># frpc.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = 服务器公网ip<br><span class="hljs-attr">server_port</span> = ×××× <span class="hljs-comment"># 与frps.ini的bind_port一致</span><br><span class="hljs-attr">token</span> = ××××  <span class="hljs-comment"># 与frps.ini的token一致</span><br><br><span class="hljs-comment"># 配置ssh服务</span><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span><br><span class="hljs-attr">remote_port</span> = ××××  <span class="hljs-comment"># 这个自定义，之后再ssh连接的时候要用</span><br><br><span class="hljs-comment"># 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的</span><br><span class="hljs-section">[web]</span><br><span class="hljs-attr">type</span> = http<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">local_port</span> = ××××<br><span class="hljs-attr">subdomain</span> = www.domain.com  <span class="hljs-comment"># web域名</span><br><span class="hljs-attr">remote_port</span> = ×××× 自定义的远程服务器端口，例如<span class="hljs-number">8080</span><br><br><span class="hljs-comment"># frp日志配置，按需配置</span><br><span class="hljs-attr">log_file</span> = /var/log/frpc.log<br><span class="hljs-attr">log_level</span> = info<br><span class="hljs-attr">log_max_days</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>配置并保存后，在当前目录下输入启动命令 <code>./frpc -c ./frpc.ini</code> 启动客户端，观察日志文件得到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/11/08 20:58:06 [I] [service.go:214] login to server success, get run id [7524d529f37d685e], server udp port [0]<br>2022/11/08 20:58:06 [I] [proxy_manager.go:137] [7524d529f37d685e] proxy added: [ssh web]<br>2022/11/08 20:58:06 [I] [control.go:143] [web] start proxy success<br>2022/11/08 20:58:06 [I] [control.go:143] [ssh] start proxy success<br></code></pre></td></tr></table></figure><h1 id="3-开机自启动设置"><a href="#3-开机自启动设置" class="headerlink" title="3 开机自启动设置"></a>3 开机自启动设置</h1><p>在 Linux 系统下，使用 systemd 可以方便地控制 frp 服务端 frps 的启动和停止、配置后台运行和开启自启。</p><h2 id="3-1-服务端"><a href="#3-1-服务端" class="headerlink" title="3.1 服务端"></a>3.1 服务端</h2><p>使用文本编辑器，如 vim 创建并编辑 frps.service ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>frps.service<br></code></pre></td></tr></table></figure><p>写入内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-comment"># 服务名称，可自定义</span><br><span class="hljs-attr">Description</span> = frp server<br><span class="hljs-attr">After</span> = network.target syslog.target<br><span class="hljs-attr">Wants</span> = network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span> = simple<br><span class="hljs-comment"># 启动frps的命令</span><br><span class="hljs-attr">ExecStart</span> = /path/to/frps -c /path/to/frps.ini<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span> = multi-user.target<br></code></pre></td></tr></table></figure><h3 id="管理-frps"><a href="#管理-frps" class="headerlink" title="管理 frps"></a>管理 frps</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 启动frp</span><br><span class="hljs-params">system</span>ctl start frps <span class="hljs-comment"># frps就是您上面创建的文件名</span><br><span class="hljs-comment"># 停止frp</span><br><span class="hljs-params">system</span>ctl stop frps<br><span class="hljs-comment"># 重启frp</span><br><span class="hljs-params">system</span>ctl restart frps<br><span class="hljs-comment"># 查看frp状态</span><br><span class="hljs-params">system</span>ctl status frps<br></code></pre></td></tr></table></figure><h3 id="配置-frps-开机自启"><a href="#配置-frps-开机自启" class="headerlink" title="配置 frps 开机自启"></a>配置 frps 开机自启</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> frps<br></code></pre></td></tr></table></figure><h2 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h2><p>使用文本编辑器，如 vim 创建并编辑 frpc.service ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>frpc.service<br></code></pre></td></tr></table></figure><p>写入内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-comment"># 服务名称，可自定义</span><br><span class="hljs-attr">Description</span> = frp client<br><span class="hljs-attr">After</span> = network.target syslog.target<br><span class="hljs-attr">Wants</span> = network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span> = simple<br><span class="hljs-comment"># 启动frps的命令</span><br><span class="hljs-attr">ExecStart</span> = /path/to/frpc -c /path/to/frpc.ini<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span> = multi-user.target<br></code></pre></td></tr></table></figure><h3 id="管理-frpc"><a href="#管理-frpc" class="headerlink" title="管理 frpc"></a>管理 frpc</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 启动frp</span><br><span class="hljs-params">system</span>ctl start frpc <span class="hljs-comment"># frpc就是您上面创建的文件名</span><br><span class="hljs-comment"># 停止frp</span><br><span class="hljs-params">system</span>ctl stop frpc<br><span class="hljs-comment"># 重启frp</span><br><span class="hljs-params">system</span>ctl restart frpc<br><span class="hljs-comment"># 查看frp状态</span><br><span class="hljs-params">system</span>ctl status frpc<br></code></pre></td></tr></table></figure><h3 id="配置-frpc-开机自启"><a href="#配置-frpc-开机自启" class="headerlink" title="配置 frpc 开机自启"></a>配置 frpc 开机自启</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> frpc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
      <tag>Systemd service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overleaf 指南</title>
    <link href="/posts/f46b227a/"/>
    <url>/posts/f46b227a/</url>
    
    <content type="html"><![CDATA[<p>本文对 Overleaf 提供的 <a href="https://www.overleaf.com/learn/LaTeX/Learn_LaTeX_in_30_minutes">Learn LaTeX in 30 minutes</a> （30 分钟 LaTeX 入门指南）以及<a href="https://www.overleaf.com/learn/how-to/Sharing_a_project">Sharing a project</a>（多人协作指南）进行了中文翻译。</p><h1 id="30-分钟-LaTeX-入门"><a href="#30-分钟-LaTeX-入门" class="headerlink" title="30 分钟 LaTeX 入门"></a>30 分钟 LaTeX 入门</h1><p>在这份指南中，我们希望给你关于 LaTeX 的首个介绍。这份指南不需要你在之前有任何关于 LaTeX 的知识，跟随这份指南你将完成你的第一份 LaTeX 文档，并将对 LaTeX 提供的一些基本功能有很好的了解。</p><h2 id="什么是-LaTeX"><a href="#什么是-LaTeX" class="headerlink" title="什么是 LaTeX"></a>什么是 LaTeX</h2><p>LaTeX（发音为 <em>LAY-tek</em> 或 _LAH-tek_）是一个用于创建具有专业外观的文档的工具。然而，LaTeX 的操作模式与您可能使用过的许多其他文档制作应用程序（例如 Microsoft Word 或 LibreOffice Writer）有很大不同：这些“<a href="https://en.wikipedia.org/wiki/WYSIWYG">所见即所得</a>”工具为用户提供了一个交互式页面，他们可以在其中键入和编辑文本并应用各种形式的造型。</p><p>LaTeX 的工作方式非常不同：相反，您的文档是一个纯文本文件，其中散布着用于表达所需（排版）结果的 LaTeX 命令。 为了生成可见的排版文档，您的 LaTeX 文件由一个称为 TeX 引擎的软件进行处理，该软件使用文本文件中嵌入的命令来指导和控制排版过程，将 LaTeX 命令和文档文本转换为专业排版 PDF 文件。 这意味着您只需关注文档的内容，计算机通过您的 LaTeX 命令和 TeX 引擎将负责视觉外观（格式）。</p><h2 id="为什么要学习-LaTeX"><a href="#为什么要学习-LaTeX" class="headerlink" title="为什么要学习 LaTeX"></a>为什么要学习 LaTeX</h2><p>可以提出各种支持或反对学习使用 LaTeX 而不是其他文档创作应用程序的论据； 但最终，这是基于偏好、兴趣和文档要求的个人选择。</p><p>支持 LaTeX 的论点包括：</p><ul><li>支持排版极其复杂的数学、表格和物理科学的技术内容；</li><li>脚注、交叉引用和参考书目管理的设施；</li><li>易于生成复杂或乏味的文档元素，例如索引、术语表、目录、图表列表；</li><li>由于其内在的可编程性和通过数千个免费附加包的可扩展性，可以高度定制定制文档生产。</li></ul><p>总体而言，LaTeX 为用户提供了对按照极高标准排版的文档制作的大量控制。 当然，有些类型的文档或出版物是 LaTeX 无法发挥作用的，包括杂志类出版物中常见的许多“自由形式”页面设计。</p><p>LaTeX 的一个重要好处是文档内容与文档样式分离：一旦您编写了文档内容，就可以轻松更改其外观。 同样，您可以创建一个 LaTeX 文件，该文件定义特定文档类型的布局&#x2F;样式，并且该文件可以用作模板来标准化该类型其他文档的作者&#x2F;制作； 例如，这允许科学出版商在 LaTeX 中创建文章模板，作者可以使用该模板撰写论文以提交给期刊。</p><p>Overleaf 的<a href="https://www.overleaf.com/gallery">图库</a>包含数千个模板，涵盖大量文档类型 - 从科学文章、报告和书籍到简历和演示文稿。 由于这些模板定义了文档的布局和样式，因此作者只需在 Overleaf 中打开它们（创建一个新项目），然后开始编写以添加其内容。</p><h2 id="编写你的第一段-LaTeX"><a href="#编写你的第一段-LaTeX" class="headerlink" title="编写你的第一段 LaTeX"></a>编写你的第一段 LaTeX</h2><p>第一步是创建一个新的 LaTeX 项目。你可以在自己的电脑上创建 <code>.tex</code> 文件，也可以 <a href="https://www.overleaf.com/learn/LaTeX/Creating_a_document_in_Overleaf">在 Overleaf 中启动新项目</a>。</p><p>让我们从最简单的示例开始：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>First document. This is a simple example, with no<br>extra parameters or packages included.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/first_project.svg"></p><p>可以看到，LaTeX 已经对文本进行了格式化（如，首行缩进）。下面我们仔细看一下上面这段代码每个部分的功能。</p><p>代码的第一行声明了文档的类型，称为 _类 (class)_。类控制文档的整体外观，不同类型的文档需要选择不同的类，比如，简历与论文需要不同的类。在这个例子中，类是 <code>article</code>，是最简单和最常见的 LaTeX 类。其他类型的文档可能需要使用不同的类，例如 <strong>book</strong> 或 <strong>report</strong>。要了解许多可用的 LaTeX 类类型，请访问 <a href="https://www.ctan.org/topic/class">CTAN</a>（Comprehensive TeX Archive Network）上的相关页面。</p><p>然后，在 <code>\begin &#123;document&#125;</code> 和 <code>\end &#123;document&#125;</code> 这两个标记之间写入文档内容。这部分就是文档的 _主体 (body)_，你可以在此处开始编写和更改文本。要在 PDF 中查看更改的结果，必须首先编译文档。在 Overleaf 中只需单击 <strong>重新编译（Recompile）</strong>。还可以单击重新编译按钮旁边的小箭头，并将 “自动编译” 设置为 “开”，这样编辑文件时项目将会自动重新编译。</p><p>现在我们已经了解了如何向我们的文档中添加内容，下一步就是撰写标题。为此，我们必须讲一下文档的 <strong>序言 (preamble)</strong></p><h2 id="文档的序言"><a href="#文档的序言" class="headerlink" title="文档的序言"></a>文档的序言</h2><p>在上一个示例中，文本是在 <code>\begin &#123;document&#125;</code> 命令之后输入的。在这个命令之前 <code>.tex</code> 文件中的所有内容都称为 **序言 (preamble)**。在序言中，可以定义要编写的文档的类型，要编写的语言，要使用的包（稍后会详细介绍）和其他的元素。</p><p>例如，普通文档的序言如下所示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br></code></pre></td></tr></table></figure><p>下面我们详细解释一下这两行的作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\documentclass<span class="hljs-selector-attr">[12pt, letterpaper]</span>&#123;<span class="hljs-selector-tag">article</span>&#125;<br></code></pre></td></tr></table></figure><p>如前所述，这条命令定义了文档的类型。跟上个示例不一样的是，方括号中还有两个参数，这些参数必须用逗号分隔。</p><p>在这个示例中，这两个额外的参数分别设置字体大小（<code>12pt</code>）和纸张大小（<code>letterpaper</code>）。</p><p>当然，可以使用其他字体大小（<code>9pt</code>，<code>11pt</code>，<code>12pt</code> 等等），但是如果未指定，则默认的字体大小为 <code>10pt</code>。纸张尺寸还可以设置为 <code>a4paper</code> 和 <code>Legalpaper</code>；更多有关 <a href="https://www.overleaf.com/learn/LaTeX/Page_size_and_margins">页面大小和边距</a> 的信息，可以参阅这篇文章。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\usepackage<span class="hljs-selector-attr">[utf8]</span>&#123;graphicx&#125;<br></code></pre></td></tr></table></figure><p>这行命令指是加载外部包（此处为<code>graphicx</code>）以扩展 LaTeX 功能的示例，<code>graphicx</code>使其能够导入外部图形文件。 LaTeX 包在查找和使用 LaTeX 包部分中讨论。</p><h2 id="添加标题、作者和日期"><a href="#添加标题、作者和日期" class="headerlink" title="添加标题、作者和日期"></a>添加标题、作者和日期</h2><p>要将标题、作者和日期添加到文档中，就必须 <strong>在序言中</strong>（不是文章的主体中）添加下面三行。它们是：</p><ul><li><p><code>\title&#123;First document&#125;</code>：这是文章的标题。</p></li><li><p><code>\author&#123;Hubert Farnsworth&#125;</code>：在此处输入作者的姓名。</p></li><li><p><code>\thanks&#123;funded by the Overleaf team&#125;</code>：在 <code>author</code> 命令的大括号里添加这条命令，可以添加上标和脚注。如果你需要在文章中感谢一个机构，这个功能将非常有用。</p></li><li><p><code>\date&#123;February 2022&#125;</code>：你可以手动输入日期，或使用 <code>\today</code> 命令，以便在编译文档时自动更新日期。</p></li></ul><p>现在，序言部分应该长这样：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\title</span>&#123;My first LaTeX document&#125;<br><span class="hljs-keyword">\author</span>&#123;Hubert Farnsworth<span class="hljs-keyword">\thanks</span>&#123;Funded by the Overleaf team.&#125;&#125;<br><span class="hljs-keyword">\date</span>&#123;August 2022&#125;<br></code></pre></td></tr></table></figure><p>现在，你已经为文档指定了标题、作者和日期，现在可以使用 <code>\maketitle</code> 命令在文档上打印这些信息。这条命令应该写在文档 <strong>主体 (body)</strong> 中你想要打印标题的位置。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br>We have now added a title, author and date to our first <span class="hljs-keyword">\LaTeX</span>&#123;&#125; document!<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>现在可以将序言和正文组合起来生成一个可以在 Overleaf 中打开的完整文档：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\title</span>&#123;My first LaTeX document&#125;<br><span class="hljs-keyword">\author</span>&#123;Hubert Farnsworth<span class="hljs-keyword">\thanks</span>&#123;Funded by the Overleaf team.&#125;&#125;<br><span class="hljs-keyword">\date</span>&#123;August 2022&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br>We have now added a title, author and date to our first <span class="hljs-keyword">\LaTeX</span>&#123;&#125; document!<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/with_preamble.svg"></p><h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>LaTeX 是“程序代码”的一种形式，但专门用于文档排版； 因此，与使用任何其他编程语言编写的代码一样，在文档中包含注释可能非常有用。注释文本不会被打印，也不会以任何方式影响文档。在调试时，注释文本对于组织工作，做笔记或注释行 &#x2F; 节很有用。</p><p>要在 LaTeX 中添加注释，只需在行首写一个<code>％</code>符号，如下所示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\maketitle</span><br><br>We have now added a title, author and date to our first <span class="hljs-keyword">\LaTeX</span>&#123;&#125; document!<br><br><span class="hljs-comment">% This line here is a comment. It will not be printed in the document.</span><br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>此示例生成的输出与之前不包含注释的 LaTeX 代码相同。</p><h2 id="加粗、斜体和下划线"><a href="#加粗、斜体和下划线" class="headerlink" title="加粗、斜体和下划线"></a>加粗、斜体和下划线</h2><p>现在让我们来看一些简单的格式化命令。</p><ul><li><strong>加粗</strong>：在 LaTeX 中，加粗字体使用 <code>\textbf&#123;&#125;</code> 命令。</li><li>_斜体_：在 LaTeX 中，斜体使用 <code>\textit&#123;&#125;</code> 命令。</li><li>下划线：在 LaTeX 中，下划线使用 <code>\underline&#123;&#125;</code> 命令。</li></ul><p>下面是示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">Some of the <span class="hljs-keyword">\textbf</span>&#123;greatest&#125;<br>discoveries in <span class="hljs-keyword">\underline</span>&#123;science&#125;<br>were made by <span class="hljs-keyword">\textbf</span>&#123;<span class="hljs-keyword">\textit</span>&#123;accident&#125;&#125;.<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/special_font_format.svg"></p><p>另一个非常有用的命令是 <code>\emph&#123;...&#125;</code> 命令。 <code>\emph</code> 是强调文本命令，她完成的操作取决于上下文：在普通文本中，强调的文本是斜体，但是如果在斜体文本中使用，则将文字变为普通文本，请参见以下示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">Some of the greatest <span class="hljs-keyword">\emph</span>&#123;discoveries&#125;<br>in science<br>were made by accident.<br><br><span class="hljs-keyword">\textit</span>&#123;Some of the greatest <span class="hljs-keyword">\emph</span>&#123;discoveries&#125;<br>in science<br>were made by accident.&#125;<br><br><span class="hljs-keyword">\textbf</span>&#123;Some of the greatest <span class="hljs-keyword">\emph</span>&#123;discoveries&#125;<br>in science<br>were made by accident.&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/special_font_format2.svg"></p><p>不过，有一些包（例如 <a href="https://www.overleaf.com/learn/Beamer">Beamer</a>），会改变 <code>\emph</code> 命令的作用。</p><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>现在我们来看，如何向 LaTeX 文档添加图片。在 Overleaf 中，你需要首先上传图片。</p><p>下面是一个如何添加图片的示例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125; <span class="hljs-comment">%LaTeX package to import graphics</span><br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;images/&#125;&#125; <span class="hljs-comment">%configuring the graphicx package</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>The universe is immense and it seems to be homogeneous,<br>on a large scale, everywhere we look.<br><br><span class="hljs-comment">% The \includegraphcs command is</span><br><span class="hljs-comment">% provided (implemented) by the</span><br><span class="hljs-comment">% graphicx package</span><br><span class="hljs-keyword">\includegraphics</span>&#123;universe&#125;<br><br>There&#x27;s a picture of a galaxy above.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/add_pic.svg"></p><p>LaTeX 本身不能管理图像，因此需要使用一个 _包 (package)_。包可用于更改 LaTeX 文档的默认外观，或实现更多功能。在这个例子中，要实现在文档中添加图片，因此需要使用 <code>graphicx</code> 包。<code>graphicx</code> 包提供了新的命令 <code>\includegraphics&#123;...&#125;</code> 和 <code>\graphicspath&#123;...&#125;</code>。要使用 <code>graphicx</code> 软件包，要现在序言中添加一行指令：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br></code></pre></td></tr></table></figure><p><code>\graphicspath&#123;&#123;images/&#125;&#125;</code> 告诉 LaTeX，这些图像保存在当前目录下名为 images 的文件夹中。</p><p><code>\includegraphics &#123;universe&#125;</code> 命令是将图像实际包含在文档中的命令。在这里，universe 是包含不带扩展名的图片文件的名称，图片文件名不应包含空格或多个点。</p><p><strong>注意</strong>：</p><ul><li>LaTeX 允许包含文件扩展名，但是最好忽略它。如果省略文件扩展名，它将提示 LaTeX 搜索所有支持的格式。</li><li>一般来说，图形的文件名不应包含空格或多个点； 还建议在将图像文件上传到 Overleaf 时使用小写字母作为文件扩展名。</li></ul><p>有关 LaTeX 包的更多信息可以在本教程末尾的查找和使用 LaTeX 包部分找到。</p><h3 id="标题、标签和引用"><a href="#标题、标签和引用" class="headerlink" title="标题、标签和引用"></a>标题、标签和引用</h3><p>我们可以像下面这样，在 <code>figure</code> 环境中对图片添加标题、标签和引用。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;images/&#125;&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;figure&#125;[h]<br>    <span class="hljs-keyword">\centering</span><br>    <span class="hljs-keyword">\includegraphics</span>[width=0.75<span class="hljs-keyword">\textwidth</span>]&#123;mesh&#125;<br>    <span class="hljs-keyword">\caption</span>&#123;A nice plot.&#125;<br>    <span class="hljs-keyword">\label</span>&#123;fig:mesh1&#125;<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br><br>As you can see in figure <span class="hljs-keyword">\ref</span>&#123;fig:mesh1&#125;, the function grows near the origin. This example is on page <span class="hljs-keyword">\pageref</span>&#123;fig:mesh1&#125;.<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/insert_pic.svg"></p><p>在这个示例中，有几个重要的命令：</p><ul><li><code>\includegraphics[width=0.75\textwidth]&#123;mesh&#125;</code>：这种形式的 <code>\includegraphics</code> 指示 LaTeX 将图形的宽度设置为文本宽度的 75%，其值存储在 \textwidth 命令中。</li><li><code>\caption&#123;A nice plot.&#125;</code>：顾名思义，此命令设置可以放置在图形上方或下方的图形标题。 如果您创建图形列表，则该标题将在该列表中使用。</li><li><code>\label&#123;fig:mesh1&#125;</code>：要在文档中引用此图像，请使用 <code>\label</code> 命令为其指定标签。 该标签用于生成图像的编号，并与下一个命令结合使用，您可以引用它。</li><li><code>\ref&#123;fig:mesh1&#125;</code>：此代码将被与引用的图形对应的数字替换。</li></ul><p>将图像放置在 LaTeX 文档中时，应始终将它们放置在 <code>figure</code> 环境或类似环境中，以便 LaTeX 适配图像和文字。</p><p>进一步的指导包含在以下帮助文章中：</p><ul><li><a href="https://www.overleaf.com/learn/LaTeX/Positioning_of_Figures">Positioning of Figures</a></li><li><a href="https://www.overleaf.com/learn/LaTeX/Inserting_Images">Inserting Images</a></li></ul><h2 id="在-LaTeX-中创建列表"><a href="#在-LaTeX-中创建列表" class="headerlink" title="在 LaTeX 中创建列表"></a>在 LaTeX 中创建列表</h2><p>在 LaTeX 中创建列表非常简单。你可以使用不同的 <em>环境 (environment)</em> 来创建不同形式的列表。环境 (environment) 是我们文档中具有不同呈现形式的各个部分。它们以 <code>\begin&#123;...&#125;</code> 命令开始，以 <code>\end&#123;...&#125;</code> 命令结束。</p><p>列表主要有两种类型，有序列表和无序列表。分别使用不同的环境。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表是由 <code>itemize</code> 环境生成的。每个条目之前必须有 <code>\item</code>，如下所示。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;itemize&#125;<br>  <span class="hljs-keyword">\item</span> The individual entries are indicated with a black dot, a so-called bullet.<br>  <span class="hljs-keyword">\item</span> The text in the entries may be of any length.<br><span class="hljs-keyword">\end</span>&#123;itemize&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/unordered_list.svg"></p><p>默认情况下，各个条目用黑点表示。条目中的文本可以是任何长度。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表在 <code>enumerate</code> 环境中创建，针对条目的语法与无序列表一致。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>  <span class="hljs-keyword">\item</span> This is the first entry in our list<br>  <span class="hljs-keyword">\item</span> The list numbers increase with each entry we add<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/ordered_list.svg"></p><p>与无序列表一样，每个条目前必须添加 <code>\item</code>，它将自动生成标记该项目的数字，由从 1 开始。</p><h2 id="在-LaTeX-中添加数学表达式"><a href="#在-LaTeX-中添加数学表达式" class="headerlink" title="在 LaTeX 中添加数学表达式"></a>在 LaTeX 中添加数学表达式</h2><p>LaTeX 的主要优点之一是易于编写数学表达式。LaTeX 中有两种模式用于数学表达式：</p><ul><li><strong>内联 (inline)模式</strong> 编写的公式是文本中的一部分</li><li><strong>显示 (display)模式</strong> 编写的公式不在段落中，而是放在单独的行上。</li></ul><h3 id="内联-inline-模式"><a href="#内联-inline-模式" class="headerlink" title="内联 (inline) 模式"></a>内联 (inline) 模式</h3><p>让我们看一个内联模式的例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">In physics, the mass-energy equivalence is stated<br>by the equation E=mc<span class="hljs-built_in">^</span>2, discovered in 1905 by Albert Einstein.<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/inline_mode.svg"></p><p>要在内联模式下添加数学表达式，可以使用以下定界符之一：<code>\(... \)</code>，<code>$ ... $</code> 或 <code>\begin&#123;math&#125; ... \end&#123;math&#125;</code>。它们作用相同，选择哪个完全取决于个人喜好。使用范例如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\documentclass[12pt,</span> letterpaper]&#123;article&#125;<br><span class="hljs-string">\begin&#123;document&#125;</span><br><span class="hljs-string">\begin&#123;math&#125;</span><br>E=mc^<span class="hljs-number">2</span><br><span class="hljs-string">\end&#123;math&#125;</span> <span class="hljs-keyword">is</span> typeset <span class="hljs-keyword">in</span> a paragraph using inline math mode---<span class="hljs-keyword">as</span> <span class="hljs-keyword">is</span> $E=mc^<span class="hljs-number">2</span>$, <span class="hljs-keyword">and</span> so too <span class="hljs-keyword">is</span> <span class="hljs-string">\(E=mc^2\).</span><br><span class="hljs-string">\end&#123;document&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/inline_mode2.svg"></p><h3 id="显示-display-模式"><a href="#显示-display-模式" class="headerlink" title="显示 (display)模式"></a>显示 (display)模式</h3><p>包含有两种版本：编号和非编号。使用范例如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>The mass-energy equivalence is described by the famous equation<br><span class="hljs-keyword">\[</span> E=mc<span class="hljs-built_in">^</span>2 <span class="hljs-keyword">\]</span> discovered in 1905 by Albert Einstein.<br><br>In natural units (<span class="hljs-built_in">$</span>c = 1<span class="hljs-built_in">$</span>), the formula expresses the identity<br><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>E=m<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/display_mode.svg"></p><p>要在显示模式下打印方程式，可以使用以下定界符之一：<code>\[... \]</code>，<code>\begin&#123;displaymath&#125; ... \end&#123;displaymath&#125;</code> 或 <code>\begin&#123;equation&#125; ... \end&#123;equation&#125;</code>。<a href="https://texfaq.org/FAQ-dolldoll"><strong>不鼓励</strong></a> 使用 <code>$$ ... $$</code>，推荐使用 LaTeX 的分隔符 <code>\[... \]</code> 代替 。</p><h3 id="更完整的例子"><a href="#更完整的例子" class="headerlink" title="更完整的例子"></a>更完整的例子</h3><p>以下示例演示了使用 LaTeX 排版的一系列数学内容。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>Subscripts in math mode are written as <span class="hljs-built_in">$</span>a<span class="hljs-built_in">_</span>b<span class="hljs-built_in">$</span> and superscripts are written as <span class="hljs-built_in">$</span>a<span class="hljs-built_in">^</span>b<span class="hljs-built_in">$</span>. These can be combined and nested to write expressions such as<br><br><span class="hljs-keyword">\[</span> T<span class="hljs-built_in">^</span>&#123;i<span class="hljs-built_in">_</span>1 i<span class="hljs-built_in">_</span>2 <span class="hljs-keyword">\dots</span> i<span class="hljs-built_in">_</span>p&#125;<span class="hljs-built_in">_</span>&#123;j<span class="hljs-built_in">_</span>1 j<span class="hljs-built_in">_</span>2 <span class="hljs-keyword">\dots</span> j<span class="hljs-built_in">_</span>q&#125; = T(x<span class="hljs-built_in">^</span>&#123;i<span class="hljs-built_in">_</span>1&#125;,<span class="hljs-keyword">\dots</span>,x<span class="hljs-built_in">^</span>&#123;i<span class="hljs-built_in">_</span>p&#125;,e<span class="hljs-built_in">_</span>&#123;j<span class="hljs-built_in">_</span>1&#125;,<span class="hljs-keyword">\dots</span>,e<span class="hljs-built_in">_</span>&#123;j<span class="hljs-built_in">_</span>q&#125;) <span class="hljs-keyword">\]</span><br><br>We write integrals using <span class="hljs-built_in">$</span><span class="hljs-keyword">\int</span><span class="hljs-built_in">$</span> and fractions using <span class="hljs-built_in">$</span><span class="hljs-keyword">\frac</span>&#123;a&#125;&#123;b&#125;<span class="hljs-built_in">$</span>. Limits are placed on integrals using superscripts and subscripts:<br><br><span class="hljs-keyword">\[</span> <span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>0<span class="hljs-built_in">^</span>1 <span class="hljs-keyword">\frac</span>&#123;dx&#125;&#123;e<span class="hljs-built_in">^</span>x&#125; =  <span class="hljs-keyword">\frac</span>&#123;e-1&#125;&#123;e&#125; <span class="hljs-keyword">\]</span><br><br>Lower case Greek letters are written as <span class="hljs-built_in">$</span><span class="hljs-keyword">\omega</span><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span><span class="hljs-keyword">\delta</span><span class="hljs-built_in">$</span> etc. while upper case Greek letters are written as <span class="hljs-built_in">$</span><span class="hljs-keyword">\Omega</span><span class="hljs-built_in">$</span> <span class="hljs-built_in">$</span><span class="hljs-keyword">\Delta</span><span class="hljs-built_in">$</span>.<br><br>Mathematical operators are prefixed with a backslash as <span class="hljs-built_in">$</span><span class="hljs-keyword">\sin</span>(<span class="hljs-keyword">\beta</span>)<span class="hljs-built_in">$</span>, <span class="hljs-built_in">$</span><span class="hljs-keyword">\cos</span>(<span class="hljs-keyword">\alpha</span>)<span class="hljs-built_in">$</span>, <span class="hljs-built_in">$</span><span class="hljs-keyword">\log</span>(x)<span class="hljs-built_in">$</span> etc.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/math_exp.svg"></p><p>下一个示例使用 <code>amsmath</code> 包提供的 <code>equation*</code> 环境，因此我们需要将以下行添加到文档序言中：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">\usepackage&#123;amsmath&#125;<span class="hljs-comment">% For the equation* environment</span><br></code></pre></td></tr></table></figure><p>equation* 环境是由外部软件包提供的，请参阅 <a href="https://www.overleaf.com/learn/LaTeX/Aligning_equations"><strong>amsmath</strong> 文章</a>。</p><p>许多数学命令都需要用到 <code>amsmath</code> 包，因此在编写数学表达式时请确保引入了这个包。下面列举了一些基本的数学命令。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<span class="hljs-comment">% For the equation* environment</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\section</span>&#123;First example&#125;<br><br>The well-known Pythagorean theorem <span class="hljs-keyword">\(</span>x<span class="hljs-built_in">^</span>2 + y<span class="hljs-built_in">^</span>2 = z<span class="hljs-built_in">^</span>2<span class="hljs-keyword">\)</span> was proved to be invalid for other exponents, meaning the next equation has no integer solutions for <span class="hljs-keyword">\(</span>n&gt;2<span class="hljs-keyword">\)</span>:<br><br><span class="hljs-keyword">\[</span> x<span class="hljs-built_in">^</span>n + y<span class="hljs-built_in">^</span>n = z<span class="hljs-built_in">^</span>n <span class="hljs-keyword">\]</span><br><br><span class="hljs-keyword">\section</span>&#123;Second example&#125;<br><br>This is a simple math expression <span class="hljs-keyword">\(</span><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<span class="hljs-keyword">\)</span> inside text.<br>And this is also the same:<br><span class="hljs-keyword">\begin</span>&#123;math&#125;<br><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<br><span class="hljs-keyword">\end</span>&#123;math&#125;<br>but by using another command.<br><br>This is a simple math expression without numbering<br><span class="hljs-keyword">\[</span><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<span class="hljs-keyword">\]</span><br>separated from text.<br><br>This is also the same:<br><span class="hljs-keyword">\begin</span>&#123;displaymath&#125;<br><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<br><span class="hljs-keyword">\end</span>&#123;displaymath&#125;<br><br><span class="hljs-keyword">\ldots</span> and this:<br><span class="hljs-keyword">\begin</span>&#123;equation*&#125;<br><span class="hljs-keyword">\sqrt</span>&#123;x<span class="hljs-built_in">^</span>2+1&#125;<br><span class="hljs-keyword">\end</span>&#123;equation*&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/math_exp2.svg"></p><p>还有太多有关在 LaTeX 中书写数学表达式的知识无法在这里一一提及。可以查看下面这些文章：</p><ul><li><a href="https://www.overleaf.com/learn/Mathematical_expressions">Mathematical expressions</a></li><li><a href="https://www.overleaf.com/learn/Subscripts_and_superscripts">Subscripts and superscripts</a></li><li><a href="https://www.overleaf.com/learn/Brackets_and_Parentheses">Brackets and Parentheses</a></li><li><a href="https://www.overleaf.com/learn/Fractions_and_Binomials">Fractions and Binomials</a></li><li><a href="https://www.overleaf.com/learn/Operators">Aligning Equations</a></li><li><a href="https://www.overleaf.com/learn/Operators">Operators</a></li><li><a href="https://www.overleaf.com/learn/Spacing_in_math_mode">Spacing in math mode</a></li><li><a href="https://www.overleaf.com/learn/Integrals,_sums_and_limits">Integrals, sums and limits</a></li><li><a href="https://www.overleaf.com/learn/Display_style_in_math_mode">Display style in math mode</a></li><li><a href="https://www.overleaf.com/learn/List_of_Greek_letters_and_math_symbols">List of Greek letters and math symbols</a></li><li><a href="https://www.overleaf.com/learn/Mathematical_fonts">Mathematical fonts</a></li></ul><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p>现在，我们来研究如何编写摘要以，及如何将 LaTeX 文档格式化为不同的章节，分节和段落。</p><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>在科学文献中，通常会在概要部分里面简述论文的主要内容。在 LaTeX 中有针对概要部分设计的环境。概要环境会将文本以特殊格式放在文档顶部。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>This is a simple paragraph at the beginning of the<br>document. A brief introduction about the main subject.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/abstract.svg"></p><h3 id="段落和新行"><a href="#段落和新行" class="headerlink" title="段落和新行"></a>段落和新行</h3><p>有了摘要，我们就可以开始写第一段了。 下一个示例演示：</p><ul><li>如何通过按两次“回车”键、结束当前行并插入后续空白行来创建新段落；</li><li>如何通过使用 <code>\\</code> 命令（双反斜杠）插入手动换行符来开始新行而不开始新段落； 或者，使用 <code>\newline</code> 命令。</li></ul><p>本示例中的第三段演示了命令<code> \\</code> 和 <code>\newline</code> 的使用：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>This is a simple paragraph at the beginning of the<br>document. A brief introduction about the main subject.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><br>After our abstract we can begin the first paragraph, then press ``enter&#x27;&#x27; twice to start the second one.<br><br>This line will start a second paragraph.<br><br>I will start the third paragraph and then add <span class="hljs-keyword">\\</span> a manual line break which causes this text to start on a new line but remains part of the same paragraph. Alternatively, I can use the <span class="hljs-keyword">\verb</span>|<span class="hljs-string">\newline</span>|<span class="hljs-keyword">\newline</span> command to start a new line, which is also part of the same paragraph.<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/newline.svg"></p><p>请注意 LaTeX 如何自动缩进段落（除非紧接在文档标题（例如节和小节）之后）。</p><p>建议新用户不要使用多个 <code>\\</code> 或 <code>\newlines</code> 来“模拟”间距较大的段落，因为这会干扰 LaTeX 的排版算法。 推荐的方法是继续使用空行创建新段落，不带任何 <code>\\</code>，并通过在序言中添加 <code>\usepackage&#123;parskip&#125;</code> 来加载 <code>parskip</code> 包。</p><p>有关段落的更多信息可以在以下文章中找到：</p><ul><li><a href="https://www.overleaf.com/learn/LaTeX/Paragraphs_and_new_lines">Paragraphs and new lines</a></li><li><a href="https://www.overleaf.com/learn/LaTeX/Articles/How_to_change_paragraph_spacing_in_LaTeX">How to change paragraph spacing in LaTeX</a></li><li><a href="https://www.overleaf.com/learn/LaTeX/Errors/LaTeX_Error%3A_There's_no_line_here_to_end">LaTeX Error: There’s no line here to end</a></li></ul><h3 id="章节和分段"><a href="#章节和分段" class="headerlink" title="章节和分段"></a>章节和分段</h3><p>较长的文档，无论使用何种创作软件，通常都会分为部分、章节、节、小节等。 LaTeX 还提供文档结构命令，但可用的命令及其实现（它们的作用）可能取决于所使用的文档类。 举例来说，使用 book 类创建的文档可以分为部分、章节、节、小节等，但 letter 类不提供（支持）任何命令来执行此操作。</p><p>下一个示例演示了用于书籍类构建文档的命令：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;book&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\chapter</span>&#123;First Chapter&#125;<br><br><span class="hljs-keyword">\section</span>&#123;Introduction&#125;<br><br>This is the first section.<br><br>Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing<br>elit. Etiam  lobortisfacilisis sem.  Nullam nec mi et<br>neque pharetra sollicitudin.  Praesent imperdietmi nec ante.<br>Donec ullamcorper, felis non sodales...<br><br><span class="hljs-keyword">\section</span>&#123;Second Section&#125;<br><br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra<br>sollicitudin.  Praesent imperdiet mi necante...<br><br><span class="hljs-keyword">\subsection</span>&#123;First Subsection&#125;<br>Praesent imperdietmi nec ante. Donec ullamcorper, felis non sodales...<br><br><span class="hljs-keyword">\section</span>*&#123;Unnumbered Section&#125;<br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Etiam lobortis facilisissem...<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/overleaf/section.svg"></p><p>切片命令的名称大多是不言自明的； 例如，<code>\chapter&#123;First Chapter&#125;</code> 创建一个标题为 <code>First Chapter</code> 的新章节，<code>\section&#123;Introduction&#125;</code> 生成标题为“<code>Introduction</code>”的部分，等等。 节可以进一步分为 <code>\subsection&#123;...&#125;</code> 甚至 <code>\subsubsection&#123;...&#125;</code>。 节、小节等的编号是自动的，但可以通过使用相应命令的所谓加星号版本来禁用，该命令末尾有星号 (<code>*</code>)，例如 <code>\section*&#123;...&#125;</code> 和 <code>\subsection *&#123;...&#125;</code>。</p><p>总的来说，LaTeX 文档类提供以下分段命令，每个特定类都支持相关子集：</p><ul><li><code>\part&#123;part&#125;</code></li><li><code>\chapter&#123;chapter&#125;</code></li><li><code>\section&#123;section&#125;</code></li><li><code>\subsection&#123;subsection&#125;</code></li><li><code>\subsubsection&#123;subsubsection&#125;</code></li><li><code>\paragraph&#123;paragraph&#125;</code></li><li><code>\subparagraph&#123;subparagraph&#125;</code></li></ul><p>请注意，<code>\part</code> 和 <code>\chapter</code> 仅在 report 和 book 类中可用。</p><p>有关文档结构的更完整讨论，请参阅 <a href="https://www.overleaf.com/learn/Sections_and_chapters">这篇文章</a>。</p><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><h3 id="在-LaTeX-中创建一个简单的表格"><a href="#在-LaTeX-中创建一个简单的表格" class="headerlink" title="在 LaTeX 中创建一个简单的表格"></a>在 LaTeX 中创建一个简单的表格</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;center&#125;<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123; c c c &#125;<br> cell1 <span class="hljs-built_in">&amp;</span> cell2 <span class="hljs-built_in">&amp;</span> cell3 <span class="hljs-keyword">\\</span><br> cell4 <span class="hljs-built_in">&amp;</span> cell5 <span class="hljs-built_in">&amp;</span> cell6 <span class="hljs-keyword">\\</span><br> cell7 <span class="hljs-built_in">&amp;</span> cell8 <span class="hljs-built_in">&amp;</span> cell9<br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;center&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/table1.svg"></p><p><code>tabular</code> 是创建表的默认 LaTeX 方法。你必须为此环境指定一个参数，这个例子里是 <code>&#123;c c c&#125;</code>。这告诉 LaTeX，表格将有三列，每列中的文本必须居中。你还可以使用 <code>r</code> 将文本向右对齐，使用 <code>l</code> 进行左对齐。符号 <code>&amp;</code> 是分隔符，每行中的分隔符必须始终少于列数。要转到表格的下一行，需要使用换行命令 <code>\\</code>。我们将整个表包装在 <code>center</code> 环境中，以让它出现在页面的中心。</p><h3 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h3><p><code>tabular</code> 支持水平线和垂直线（规则）作为表格的一部分：</p><ul><li>要在行上方和下方添加水平线，请使用 \hline 命令</li><li>要在列之间添加垂直线，请使用垂直线参数 |</li></ul><p>在此示例中，参数是 <code>&#123;|c|c|c|&#125;</code>，它声明了三个（居中）列，每个列由垂直线分隔； 此外，我们使用 <code>\hline</code> 在第一行上方和最后一行下方放置水平线：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;center&#125;<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123; |c|c|c| &#125;<br> <span class="hljs-keyword">\hline</span><br> cell1 <span class="hljs-built_in">&amp;</span> cell2 <span class="hljs-built_in">&amp;</span> cell3 <span class="hljs-keyword">\\</span><br> cell4 <span class="hljs-built_in">&amp;</span> cell5 <span class="hljs-built_in">&amp;</span> cell6 <span class="hljs-keyword">\\</span><br> cell7 <span class="hljs-built_in">&amp;</span> cell8 <span class="hljs-built_in">&amp;</span> cell9 <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;center&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/table2.svg"></p><p>在下面你可以看到第二个示例。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;center&#125;<br> <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;||c c c c||&#125;<br> <span class="hljs-keyword">\hline</span><br> Col1 <span class="hljs-built_in">&amp;</span> Col2 <span class="hljs-built_in">&amp;</span> Col2 <span class="hljs-built_in">&amp;</span> Col3 <span class="hljs-keyword">\\</span> [0.5ex]<br> <span class="hljs-keyword">\hline</span><span class="hljs-keyword">\hline</span><br> 1 <span class="hljs-built_in">&amp;</span> 6 <span class="hljs-built_in">&amp;</span> 87837 <span class="hljs-built_in">&amp;</span> 787 <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br> 2 <span class="hljs-built_in">&amp;</span> 7 <span class="hljs-built_in">&amp;</span> 78 <span class="hljs-built_in">&amp;</span> 5415 <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br> 3 <span class="hljs-built_in">&amp;</span> 545 <span class="hljs-built_in">&amp;</span> 778 <span class="hljs-built_in">&amp;</span> 7507 <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br> 4 <span class="hljs-built_in">&amp;</span> 545 <span class="hljs-built_in">&amp;</span> 18744 <span class="hljs-built_in">&amp;</span> 7560 <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br> 5 <span class="hljs-built_in">&amp;</span> 88 <span class="hljs-built_in">&amp;</span> 788 <span class="hljs-built_in">&amp;</span> 6344 <span class="hljs-keyword">\\</span> [1ex]<br> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;center&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/table3.svg"></p><blockquote><p>在 LaTeX 中创建表有时会有些棘手，因此你可能需要 <a href="https://www.tablesgenerator.com/">TablesGenerator.com</a> 这样的在线工具导出表格的 LaTeX 代码。<em>“文件”&gt;“粘贴表数据”</em> 选项从电子表格软件粘贴数据。</p></blockquote><h3 id="标题、标签和引用-1"><a href="#标题、标签和引用-1" class="headerlink" title="标题、标签和引用"></a>标题、标签和引用</h3><p>你可以使用与图片几乎相同的方式来为表格添加标题、标签和引用。唯一的区别是，使用 <code>table</code> 代替了 <code>figure</code> 。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tex">Table <span class="hljs-keyword">\ref</span>&#123;table:data&#125; shows how to add a table caption and reference a table.<br><span class="hljs-keyword">\begin</span>&#123;table&#125;[h!]<br><span class="hljs-keyword">\centering</span><br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;||c c c c||&#125;<br> <span class="hljs-keyword">\hline</span><br> Col1 <span class="hljs-built_in">&amp;</span> Col2 <span class="hljs-built_in">&amp;</span> Col2 <span class="hljs-built_in">&amp;</span> Col3 <span class="hljs-keyword">\\</span> [0.5ex]<br> <span class="hljs-keyword">\hline</span><span class="hljs-keyword">\hline</span><br> 1 <span class="hljs-built_in">&amp;</span> 6 <span class="hljs-built_in">&amp;</span> 87837 <span class="hljs-built_in">&amp;</span> 787 <span class="hljs-keyword">\\</span><br> 2 <span class="hljs-built_in">&amp;</span> 7 <span class="hljs-built_in">&amp;</span> 78 <span class="hljs-built_in">&amp;</span> 5415 <span class="hljs-keyword">\\</span><br> 3 <span class="hljs-built_in">&amp;</span> 545 <span class="hljs-built_in">&amp;</span> 778 <span class="hljs-built_in">&amp;</span> 7507 <span class="hljs-keyword">\\</span><br> 4 <span class="hljs-built_in">&amp;</span> 545 <span class="hljs-built_in">&amp;</span> 18744 <span class="hljs-built_in">&amp;</span> 7560 <span class="hljs-keyword">\\</span><br> 5 <span class="hljs-built_in">&amp;</span> 88 <span class="hljs-built_in">&amp;</span> 788 <span class="hljs-built_in">&amp;</span> 6344 <span class="hljs-keyword">\\</span> [1ex]<br> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\caption</span>&#123;Table to test captions and labels.&#125;<br><span class="hljs-keyword">\label</span>&#123;table:data&#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/table4.svg"></p><h2 id="添加目录"><a href="#添加目录" class="headerlink" title="添加目录"></a>添加目录</h2><p>创建目录很简单，使用 <code>\tableofcontents</code> 即可完成所有工作：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\title</span>&#123;Sections and Chapters&#125;<br><span class="hljs-keyword">\author</span>&#123;Gubert Farnsworth&#125;<br><span class="hljs-keyword">\date</span>&#123;August 2022&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\maketitle</span><br><br><span class="hljs-keyword">\tableofcontents</span><br><br><span class="hljs-keyword">\section</span>&#123;Introduction&#125;<br><br>This is the first section.<br><br>Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing<br>elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et<br>neque pharetra sollicitudin.  Praesent imperdietmi nec ante.<br>Donec ullamcorper, felis non sodales...<br><br><span class="hljs-keyword">\section</span>*&#123;Unnumbered Section&#125;<br><span class="hljs-keyword">\addcontentsline</span>&#123;toc&#125;&#123;section&#125;&#123;Unnumbered Section&#125;<br><br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra<br>sollicitudin.  Praesent imperdiet mi necante...<br><br><span class="hljs-keyword">\section</span>&#123;Second Section&#125;<br><br>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Etiam lobortis facilisissem.  Nullam nec mi et neque pharetra<br>sollicitudin.  Praesent imperdiet mi necante...<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/overleaf/contents.svg"></p><p><code>section</code>&#x2F;<code>subsection</code>&#x2F;<code>chapter</code> 将会自动加入目录当中。如果需要加入手动添加目录条目，比如需要将非编号的 <code>section</code> 加入目录，需要像示例中那样使用 <code>\addcontentsline</code>。</p><h2 id="下载写好的文档"><a href="#下载写好的文档" class="headerlink" title="下载写好的文档"></a>下载写好的文档</h2><p>你可以通过单击左上角的 “菜单” 按钮来下载完成的 PDF。还有一个更快的方法，就是单击 PDF 查看器上的 “下载 PDF” 按钮，如下所示。</p><p><img src="/img/overleaf/download.png"></p><h2 id="查找并使用-LaTeX-包"><a href="#查找并使用-LaTeX-包" class="headerlink" title="查找并使用 LaTeX 包"></a>查找并使用 LaTeX 包</h2><p>LaTeX 不仅提供了重要的排版功能，而且还通过使用附加包提供了可扩展性的框架。 LaTeX 不是试图提供“尝试做所有事情”的命令和功能，而是被设计为可扩展的，允许用户加载提供更专业排版功能或扩展 LaTeX 内置功能的外部代码体（包），例如 排版表。 正如添加图像部分中所看到的，<code>graphicx</code> 包通过提供导入图形文件的命令来扩展 LaTeX，并通过以下命令来加载（在序言中）</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br></code></pre></td></tr></table></figure><h3 id="加载包"><a href="#加载包" class="headerlink" title="加载包"></a>加载包</h3><p>如上所述，包通过 <code>\usepackage</code> 命令加载到文档序言中，但由于（许多）LaTeX 包提供了一组选项，可用于配置其行为，<code>\usepackage</code> 命令通常如下所示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>[options]&#123;somepackage&#125;<br></code></pre></td></tr></table></figure><p>方括号“<code>[...]</code>”告知 LaTeX 在加载某个包时应应用哪组选项。 在用户请求的选项集中，各个选项或设置通常用逗号分隔； 例如，<code>geometry</code> 包提供了许多选项来配置 LaTeX 中的页面布局，因此 <code>geometry</code> 的典型用法可能如下所示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>[总计=&#123;6.5in,8.75in&#125;,<br>top=1.2in, left=0.9in, includefoot]&#123;geometry&#125;<br></code></pre></td></tr></table></figure><p><code>geometry</code> 是由全球 LaTeX 社区成员编写和贡献的包的一个示例，并且免费提供给任何想要使用它的人。</p><p>如果一个 LaTeX 包没有提供任何选项，或者用户想要使用包选项的默认值，那么它将像这样加载：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;somepackage&#125;<br></code></pre></td></tr></table></figure><p>当您编写 <code>\usepackage[...]&#123;somepackage&#125;</code> 时，LATEX 会查找名为 <code>somepackage.sty</code> 的相应文件，它需要加载和处理该文件，以使包命令可用并执行该包提供的任何其他代码。 如果 LATEX 找不到 <code>somepackage.sty</code> ，它将终止并出现错误，如以下 Overleaf 示例所示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[12pt, letterpaper]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;somepackage&#125;<span class="hljs-comment">% a NON-EXISTENT package</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br>This will fail!<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="查找有关包的信息：CTAN"><a href="#查找有关包的信息：CTAN" class="headerlink" title="查找有关包的信息：CTAN"></a>查找有关包的信息：CTAN</h3><p>您可以浏览 CTAN 寻找有用的软件包； 例如：</p><ul><li><a href="https://www.ctan.org/topics/cloud">by topic</a></li><li><a href="https://www.ctan.org/pkg">alphabetically</a> (根据名称)</li></ul><p>您还可以使用（位于页面顶部）的<a href="https://www.ctan.org/pkg">搜索工具</a></p><h3 id="Overleaf-可用软件包：TeX-Live-简介"><a href="#Overleaf-可用软件包：TeX-Live-简介" class="headerlink" title="Overleaf 可用软件包：TeX Live 简介"></a>Overleaf 可用软件包：TeX Live 简介</h3><p>每年，CTAN 上托管的（大型）软件包子集以及与 LaTeX 相关的字体和其他软件都会被整理并作为名为 TeX Live 的系统分发，该系统可用于安装您自己的（本地）LaTeX 设置。 事实上，Overleaf 的服务器也使用 TeX Live，并在 TeX Live 新版本发布时进行更新。 Overleaf 的 TeX Live 更新不是立即进行的，而是在发布后几个月进行，这让我们有时间对新的 TeX Live 版本与我们库中包含的数千个模板进行兼容性测试。 例如，这是我们的 TeX Live 2022 升级公告。</p><p>尽管 TeX Live 包含 CTAN 包的（大）子集，但可以找到一个有趣的包，例如用于排版 Go 图的 igo，它托管在 CTAN 上，但不包含在 TeX Live 中（由其分发），因此在 Overleaf 上不可用。 由于多种原因，CTAN 上托管的某些软件包不是 TeX Live 的一部分：可能某个软件包已过时、存在许可问题、非常新（最近上传）或具有平台依赖性，例如在 Windows 上运行但不能在 Linux 上运行。</p><p>新软件包以及现有软件包的更新全年都会上传到 CTAN，但 TeX Live 的更新每年都会分发； 因此，当前版本的 TeX Live 中包含的软件包将不会像 CTAN 上托管的软件包那样是最新的。 由于 Overleaf 的服务器使用 TeX Live，因此我们服务器上安装的软件包（即可供用户使用的软件包）可能不是 CTAN 上可用的最新版本，但一般来说，这不太可能出现问题。</p><h1 id="多人协作指南"><a href="#多人协作指南" class="headerlink" title="多人协作指南"></a>多人协作指南</h1><p>Overleaf 的主要功能之一是能够共享项目并与其他用户协作。</p><h2 id="链接分享"><a href="#链接分享" class="headerlink" title="链接分享"></a>链接分享</h2><p>“链接共享”允许项目所有者通过不同类型的链接共享他们的项目：</p><ul><li>任何拥有只读链接的人都应该能够访问和阅读相关的 Overleaf 项目</li><li>任何拥有编辑链接的人（ 如果他们已经有 Overleaf 帐户）都可以编辑关联的 Overleaf 项目，否则他们首先需要创建一个帐户</li></ul><p>要访问链接共享：</p><ol><li><p>单击项目右上角的共享按钮<br><img src="/img/overleaf/share1.png"></p></li><li><p>单击打开链接共享<br><img src="/img/overleaf/sharepublic1.png" alt="Sharepublic1.PNG"></p></li><li></li><li><p>将显示可共享的读取和编辑以及只读 URL<br><img src="/img/overleaf/sharepublicreadwrite.png" alt="Sharepublicreadwrite.png"></p><p>要让某人访问该项目，只需向他们发送该项目的 URL 即可。 请注意，用户必须拥有 Overleaf 帐户才能编辑链接共享项目。</p></li></ol><h2 id="邀请指定合作者"><a href="#邀请指定合作者" class="headerlink" title="邀请指定合作者"></a>邀请指定合作者</h2><p>与指定协作者共享项目的功能更加强大，因为唯一被允许访问该项目的人是您邀请参与该项目的人员。 与某人共享项目：</p><ul><li>单击项目右上角的共享按钮</li></ul><p><img src="/img/overleaf/share1.png"></p><ul><li>输入您想要与其共享项目的帐户的电子邮件地址：</li></ul><p><img src="/img/overleaf/share2.png" alt="Share2.PNG"></p><ul><li>选择您是否希望协作者具有只读访问权限，或者是否允许他们编辑项目。</li><li>点击分享</li></ul><p>您的合作者现在将收到一封电子邮件，邀请他们加入该项目。 一旦他们登录到自己的帐户，他们将能够接受邀请并就项目进行协作。 共享项目窗口将更新以显示他们已接受请求并加入项目。 如果他们没有收到电子邮件：</p><ul><li>确保您使用的电子邮件地址正确</li><li>尝试通过单击共享项目窗口中的重新发送来重新发送电子邮件</li><li>检查电子邮件地址的垃圾邮件文件夹，因为有时电子邮件可能会被错误地放入其中。</li></ul><h2 id="允许的协作者数量"><a href="#允许的协作者数量" class="headerlink" title="允许的协作者数量"></a>允许的协作者数量</h2><p>扩展命名共享是一项高级功能。 Overleaf 高级功能可供 Overleaf Commons 的参与者、团体订阅的成员和个人订阅的所有者使用。 您可以邀请的合作者数量将取决于您所属的计划。 访问订阅计划页面以查看可用的不同计划。</p>]]></content>
    
    
    <categories>
      
      <category>常用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Overleaf</tag>
      
      <tag>Latex</tag>
      
      <tag>collaborate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPDK安装与使用</title>
    <link href="/posts/a948432a/"/>
    <url>/posts/a948432a/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装-FIO"><a href="#1-安装-FIO" class="headerlink" title="1 安装 FIO"></a>1 安装 FIO</h1><p>为了便于对 SPDK 进行测试，需要集成 FIO。根据文档，需要先手动编译安装 FIO</p><h2 id="1-1-下载-FIO-源码"><a href="#1-1-下载-FIO-源码" class="headerlink" title="1.1 下载 FIO 源码"></a>1.1 下载 FIO 源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/axboe/fio<br></code></pre></td></tr></table></figure><h2 id="1-2-编译安装"><a href="#1-2-编译安装" class="headerlink" title="1.2 编译安装"></a>1.2 编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><h1 id="2-配置-SPDK"><a href="#2-配置-SPDK" class="headerlink" title="2 配置 SPDK"></a>2 配置 SPDK</h1><h2 id="2-1-下载-SPDK-源码"><a href="#2-1-下载-SPDK-源码" class="headerlink" title="2.1 下载 SPDK 源码"></a>2.1 下载 SPDK 源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/spdk/spdk<br><span class="hljs-built_in">cd</span> spdk<br>git submodule update --init<br></code></pre></td></tr></table></figure><h2 id="2-2-编译-SPDK"><a href="#2-2-编译-SPDK" class="headerlink" title="2.2 编译 SPDK"></a>2.2 编译 SPDK</h2><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./scripts/pkgdep.sh<br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --with-fio=/path/to/fio<br>make<br></code></pre></td></tr></table></figure><h2 id="2-3-修改-FEMU（Optional）"><a href="#2-3-修改-FEMU（Optional）" class="headerlink" title="2.3 修改 FEMU（Optional）"></a>2.3 修改 FEMU（Optional）</h2><blockquote><p>如果使用 FEMU 模拟固态盘，由于 FEMU 中对 NVMe 协议的部分 Admin 命令没有进行实现，需要自行完善。以下方法仅用于暂时屏蔽问题。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">--- a/hw/femu/nvme-admin.c<br>+++ b/hw/femu/nvme-admin.c<br>@@ -999,6 +999,8 @@ static uint16_t nvme_admin_cmd(FemuCtrl *n, NvmeCmd *cmd, NvmeCqe *cqe)<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_SET_DB_MEMORY:<br>         femu_debug(<span class="hljs-string">&quot;admin cmd,set_db_memory\n&quot;</span>);<br>         <span class="hljs-built_in">return</span> nvme_set_db_memory(n, cmd);<br>+    <span class="hljs-keyword">case</span> NVME_ADM_CMD_ASYNC_EV_REQ:<br>+        <span class="hljs-built_in">return</span> NVME_SUCCESS;<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_ACTIVATE_FW:<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_DOWNLOAD_FW:<br>     <span class="hljs-keyword">case</span> NVME_ADM_CMD_SECURITY_SEND:<br></code></pre></td></tr></table></figure><h2 id="2-4-运行"><a href="#2-4-运行" class="headerlink" title="2.4 运行"></a>2.4 运行</h2><h3 id="2-4-1-设备初始化"><a href="#2-4-1-设备初始化" class="headerlink" title="2.4.1 设备初始化"></a>2.4.1 设备初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/spdk<br>sudo scripts/setup.sh<br></code></pre></td></tr></table></figure><h3 id="2-4-2-生成配置文件"><a href="#2-4-2-生成配置文件" class="headerlink" title="2.4.2 生成配置文件"></a>2.4.2 生成配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo scripts/gen_nvme.sh --json-with-subsystems &gt; nvme.json<br></code></pre></td></tr></table></figure><p>以具有两个 NVMe 设备的系统为例，生成结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;subsystems&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;subsystem&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bdev&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bdev_nvme_attach_controller&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;trtype&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PCIe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Nvme0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;traddr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0000:00:06.0&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bdev_nvme_attach_controller&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;trtype&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PCIe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Nvme1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;traddr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0000:00:07.0&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-启动-spdk"><a href="#2-4-3-启动-spdk" class="headerlink" title="2.4.3 启动 spdk"></a>2.4.3 启动 spdk</h3><p>方法一（指定配置文件启动）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/spdk<br>sudo scripts/setup.sh<br>sudo build/bin/spdk_tgt --json nvme.json<br></code></pre></td></tr></table></figure><p>方法二（RPC 命令创建设备）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#First shell</span><br><span class="hljs-built_in">cd</span> /path/to/spdk<br>sudo scripts/setup.sh<br>sudo build/bin/spdk_tgt<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Second shell</span><br><span class="hljs-comment">#具体参数值可根据gen_nvme.sh的生成结果来设置</span><br>sudo scripts/rpc.py bdev_nvme_attach_controller -b nvme1 -a 00:06.0 -t pcie<br></code></pre></td></tr></table></figure><blockquote><p>如果需要帮助信息，可以通过<code>-h</code>参数来查看</p><p>sudo scripts&#x2F;rpc.py -h</p><p>sudo scripts&#x2F;rpc.py bdev_nvme_attach_controller -h</p></blockquote><p>检查设备是否创建成功，可使用 SPDK 提供的 client 程序进行查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo scripts/spdkcli.py <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><blockquote><p>更多工具，可查看 SPDK 项目中的 scripts 子目录</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译</title>
    <link href="/posts/3473f5e6/"/>
    <url>/posts/3473f5e6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1 安装依赖"></a>1 安装依赖</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install -y build-essential bison flex libssl-dev libelf-dev libcap-dev libattr1-dev libncurses-dev<br></code></pre></td></tr></table></figure><h1 id="2-下载内核"><a href="#2-下载内核" class="headerlink" title="2 下载内核"></a>2 下载内核</h1><p>可先在第一条指令中的网站选择合适的 linux 版本，然后替换网址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v4.x/linux-4.19.tar.gz<br>tar zxf linux-4.19.tar.gz<br><span class="hljs-built_in">cd</span> linux-4.19<br></code></pre></td></tr></table></figure><h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h1><h2 id="3-1-设置-GCC-版本（可选）"><a href="#3-1-设置-GCC-版本（可选）" class="headerlink" title="3.1 设置 GCC 版本（可选）"></a>3.1 设置 GCC 版本（可选）</h2><p>不同版本的 linux 需要使用的 gcc 版本不同，如：linux-4.19 需要使用 gcc-7。可通过以下命令设置默认使用的 gcc 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 数值越大，优先级越高。值最大的版本为默认使用的版本</span><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 90<br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80<br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 80<br></code></pre></td></tr></table></figure><p>使用以下命令可清除上述配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --remove-all gcc<br></code></pre></td></tr></table></figure><h2 id="3-2-生成-config"><a href="#3-2-生成-config" class="headerlink" title="3.2 生成 config"></a>3.2 生成 config</h2><p>有图形界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><p>无图形界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">yes</span> <span class="hljs-string">&quot;&quot;</span> | make oldconfig<br></code></pre></td></tr></table></figure><p>生成配置文件<code>.config</code>后，需要进行简单的修改，将以下配置设置为空。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#可能有多个类似的设置项，可根据下一步的编译结果针对性修改</span><br>CONFIG_SYSTEM_TRUSTED_KEYS=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-3-编译"><a href="#3-3-编译" class="headerlink" title="3.3 编译"></a>3.3 编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j16<br>sudo make INSTALL_MOD_STRIP=1 modules_install<br>sudo make install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FEMU安装与使用</title>
    <link href="/posts/e9ca848d/"/>
    <url>/posts/e9ca848d/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装-femu"><a href="#1-安装-femu" class="headerlink" title="1 安装 femu"></a>1 安装 femu</h1><h2 id="1-1-安装-femu-依赖库"><a href="#1-1-安装-femu-依赖库" class="headerlink" title="1.1 安装 femu 依赖库"></a>1.1 安装 femu 依赖库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/ucare-uchicago/femu.git<br><span class="hljs-built_in">cd</span> femu<br><span class="hljs-built_in">mkdir</span> build-femu<br><span class="hljs-comment"># Switch to the FEMU building directory</span><br><span class="hljs-built_in">cd</span> build-femu<br><span class="hljs-comment"># Copy femu script</span><br><span class="hljs-built_in">cp</span> ../femu-scripts/femu-copy-scripts.sh .<br>./femu-copy-scripts.sh .<br><span class="hljs-comment"># only Debian/Ubuntu based distributions supported</span><br>sudo ./pkgdep.sh<br></code></pre></td></tr></table></figure><h2 id="1-2-编译安装-femu"><a href="#1-2-编译安装-femu" class="headerlink" title="1.2 编译安装 femu"></a>1.2 编译安装 femu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./femu-compile.sh<br></code></pre></td></tr></table></figure><h2 id="1-3-准备虚拟机镜像"><a href="#1-3-准备虚拟机镜像" class="headerlink" title="1.3 准备虚拟机镜像"></a>1.3 准备虚拟机镜像</h2><p>使用官方镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/images/<br><span class="hljs-built_in">cd</span> ~/images<br>wget http://people.cs.uchicago.edu/~huaicheng/femu/femu-vm.tar.xz<br>tar xJvf femu-vm.tar.xz<br></code></pre></td></tr></table></figure><p>自制镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Download a Ubuntu server ISO file</span><br><span class="hljs-built_in">mkdir</span> -p ~/images/<br><span class="hljs-built_in">cd</span> ~/images<br>wget https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/16.04/ubuntu-16.04.7-server-amd64.iso<br>sudo apt-get install qemu-system-x86<br><span class="hljs-comment"># Create a QCOW2 disk image</span><br>qemu-img create -f qcow2 femu.qcow2 80G<br><span class="hljs-comment"># install guest OS to femu.qcow2 (You need a GUI environment to prepare the VM image)</span><br>sudo qemu-system-x86_64 -cdrom ubuntu-16.04.7-server-amd64.iso -hda femu.qcow2 -boot d -net nic -net user -m 4096 -localtime -smp 4 -cpu host -enable-kvm<br></code></pre></td></tr></table></figure><p>虚拟机创建完成后，可使用以下命令验证系统是否正确安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo qemu-system-x86_64 -hda femu.qcow2 -net nic -net user -m 4096 -localtime -smp 4 -cpu host -enable-kvm<br></code></pre></td></tr></table></figure><h2 id="1-4-启动-femu"><a href="#1-4-启动-femu" class="headerlink" title="1.4 启动 femu"></a>1.4 启动 femu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/femu<br><span class="hljs-built_in">cd</span> build-femu<br>./run-blackbox.sh<br></code></pre></td></tr></table></figure><h1 id="2-共享文件夹配置"><a href="#2-共享文件夹配置" class="headerlink" title="2 共享文件夹配置"></a>2 共享文件夹配置</h1><p>为便于进行文件管理，可以通过 9p 文件系统在虚拟机中挂载宿主机文件夹。这种方式要求虚拟机和宿主机的内核都开启了对 9p 文件系统的支持。</p><blockquote><p>如果内核没有开启该功能，可通过 scp 命令进行主机间文件的共享</p></blockquote><h2 id="2-1-准备共享文件夹"><a href="#2-1-准备共享文件夹" class="headerlink" title="2.1 准备共享文件夹"></a>2.1 准备共享文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/share<br></code></pre></td></tr></table></figure><h2 id="2-2-修改femu-compile-sh"><a href="#2-2-修改femu-compile-sh" class="headerlink" title="2.2 修改femu-compile.sh"></a>2.2 修改<code>femu-compile.sh</code></h2><p>编译 femu 时增加<code>--enable-virtfs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install -y libcap-ng-dev libattr1-dev<br>../configure --enable-kvm --target-list=x86_64-softmmu --enable-virtfs<br></code></pre></td></tr></table></figure><h2 id="2-3-修改run-blackbox-sh"><a href="#2-3-修改run-blackbox-sh" class="headerlink" title="2.3 修改run-blackbox.sh"></a>2.3 修改<code>run-blackbox.sh</code></h2><p>在启动命令上方增加一个环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SHARE_DIR=<span class="hljs-variable">$HOME</span>/share<br></code></pre></td></tr></table></figure><p>启动 femu 时增加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-fsdev <span class="hljs-built_in">local</span>,path=<span class="hljs-variable">$SHARE_DIR</span>,<span class="hljs-built_in">id</span>=share_dir,security_model=none \<br>-device virtio-9p-pci,fsdev=share_dir,mount_tag=hostshare \<br></code></pre></td></tr></table></figure><h2 id="2-4-挂载文件夹"><a href="#2-4-挂载文件夹" class="headerlink" title="2.4 挂载文件夹"></a>2.4 挂载文件夹</h2><p>方式一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mount -t 9p -o trans=virtio hostshare ~/share/ -oversion=9p2000.L<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim /etc/fstab</span><br><span class="hljs-comment"># 在文件末尾追加一行</span><br>hostshare /path/to/share 9p trans=virtio,version=9p2000.L 0 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS Code配置教程</title>
    <link href="/posts/b3d38a78/"/>
    <url>/posts/b3d38a78/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装-VS-Code"><a href="#1-安装-VS-Code" class="headerlink" title="1 安装 VS Code"></a>1 安装 VS Code</h1><p><a href="https://code.visualstudio.com/">官网下载</a></p><h1 id="2-插件"><a href="#2-插件" class="headerlink" title="2 插件"></a>2 插件</h1><h2 id="2-1-Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code"><a href="#2-1-Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="2.1 Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code"></a>2.1 Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</h2><p>提供中文操作界面</p><h2 id="2-2-C-x2F-C"><a href="#2-2-C-x2F-C" class="headerlink" title="2.2 C&#x2F;C++"></a>2.2 C&#x2F;C++</h2><p>提供语法检查&#x2F;提示、代码调试等功能</p><h2 id="2-3-clangd"><a href="#2-3-clangd" class="headerlink" title="2.3 clangd"></a>2.3 clangd</h2><p>提供更加强大的语法提示&#x2F;补全、导航等功能</p><h3 id="2-3-1-安装依赖"><a href="#2-3-1-安装依赖" class="headerlink" title="2.3.1 安装依赖"></a>2.3.1 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install clangd<br></code></pre></td></tr></table></figure><p>VSCode 新窗口中打开项目根目录所在文件夹。<code>Ctrl+Shift+p</code>打开命令面板，输入以下命令后回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clangd: Download language server<br></code></pre></td></tr></table></figure><h3 id="2-3-2-生成-compile-commands-json"><a href="#2-3-2-生成-compile-commands-json" class="headerlink" title="2.3.2 生成 compile_commands.json"></a>2.3.2 生成 compile_commands.json</h3><p>安装 bear</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install bear<br></code></pre></td></tr></table></figure><p>使用方法：将正常编译命令作为 bear 的参数， 示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bear make -j 16<br></code></pre></td></tr></table></figure><h3 id="2-3-3-生成配置文件"><a href="#2-3-3-生成配置文件" class="headerlink" title="2.3.3 生成配置文件"></a>2.3.3 生成配置文件</h3><p>VSCode 新窗口中打开项目根目录所在文件夹。创建文件夹<code>.vscode</code>，然后创建文件<code>settings.json</code>，对插件进行设定。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;C_Cpp.inlayHints.parameterNames.enabled&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;C_Cpp.intelliSenseEngine&quot;</span>: <span class="hljs-string">&quot;disabled&quot;</span>,<br>    <span class="hljs-string">&quot;C_Cpp.default.compileCommands&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>/build-femu/compile_commands.json&quot;</span>,<br>    <span class="hljs-string">&quot;clangd.arguments&quot;</span>: [<br>        <span class="hljs-string">&quot;--compile-commands-dir=<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>/build-femu&quot;</span>,<br>        <span class="hljs-string">&quot;--header-insertion=never&quot;</span>,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>C_Cpp.default.compileCommands</code>应设置为<code>compile_commands.json</code>文件的访问路径</p><p><code>compile-commands-dir</code>应设置为<code>compile_commands.json</code>文件所在目录的访问路径</p></blockquote><h1 id="3-代码调试功能配置"><a href="#3-代码调试功能配置" class="headerlink" title="3 代码调试功能配置"></a>3 代码调试功能配置</h1><h2 id="3-1-配置方式"><a href="#3-1-配置方式" class="headerlink" title="3.1 配置方式"></a>3.1 配置方式</h2><p>VSCode 新窗口中打开项目根目录所在文件夹。创建文件夹<code>.vscode</code>，然后创建文件<code>launch.json</code>，进行设定。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    // 使用 IntelliSense 了解相关属性。<br>    // 悬停以查看现有属性的描述。<br>    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;(gdb) 启动&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>/build-femu/x86_64-softmmu/qemu-system-x86_64&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: [],<br>            <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;fileDirname&#125;</span>&quot;</span>,<br>            <span class="hljs-string">&quot;environment&quot;</span>: [],<br>            <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-string">&quot;miDebuggerServerAddress&quot;</span>: <span class="hljs-string">&quot;127.0.0.1:1234&quot;</span>,<br>            <span class="hljs-string">&quot;setupCommands&quot;</span>: [<br>                &#123;<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,<br>                    <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-string">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span>,<br>                    <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span>,<br>                    <span class="hljs-string">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;禁止用户中断1&quot;</span>,<br>                    <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;handle SIGUSR1 noprint nostop&quot;</span>,<br>                    <span class="hljs-string">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">false</span><br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>program</code>应设置为需要调试的二进制文件的访问路径</p><p><code>miDebuggerServerAddress</code>应设置为与启动<code>gdbserver</code>时的设置相同</p></blockquote><h2 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h2><p>在<code>shell</code>中启动<code>gdbserver</code>，将原有的程序运行命令作为 gdbserver 的参数之一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gdbserver localhost:2222 qemu-system-x86_64 …<br></code></pre></td></tr></table></figure><p>在 VSCode 的<code>运行和调试</code>窗口中，启动调试。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb</tag>
      
      <tag>VS Code</tag>
      
      <tag>clangd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署教程</title>
    <link href="/posts/69b496a5/"/>
    <url>/posts/69b496a5/</url>
    
    <content type="html"><![CDATA[<p>本文记录了使用 Hexo 搭建博客的主要过程，利用 Github Pages 以及 Github Action 实现了网站的自动部署。</p><!--more --><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1 创建仓库"></a>1 创建仓库</h3><h4 id="1-1-网页端创建"><a href="#1-1-网页端创建" class="headerlink" title="1.1 网页端创建"></a>1.1 网页端创建</h4><p>建立两个 Github 空仓库，一个设为<code>private</code>，一个设为<code>public</code>。例如，私有仓库命名为<code>blog</code>，公开仓库命名为<code>Username.github.io</code>。</p><h4 id="1-2-本地创建密钥对"><a href="#1-2-本地创建密钥对" class="headerlink" title="1.2 本地创建密钥对"></a>1.2 本地创建密钥对</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的GitHub用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br><br>ssh-keygen -t rsa -f github_deploy_key<br></code></pre></td></tr></table></figure><h4 id="1-3-密钥配置"><a href="#1-3-密钥配置" class="headerlink" title="1.3 密钥配置"></a>1.3 密钥配置</h4><p>为了避免博客系统更新过程中的密码输入，需要配置使用密钥进行更新。</p><p>私有仓库需要添加私钥，私钥设置方式如下：</p><blockquote><p>Settings → Security → Secrets → Actions → New repository secret</p></blockquote><blockquote><p>Name 设置为 HEXO_DEPLOY_PRI</p><p>Value 为上一步中生成的 github-deploy-key 文件的全部内容</p></blockquote><p>公开仓库需要添加公钥，公钥设置方式如下：</p><blockquote><p>Settings → Security → Deploy keys → Add deploy key</p></blockquote><blockquote><p>Title 设置为 HEXO_DEPLOY_PUB</p><p>Key 为上一步中生成的 github-deploy-key.pub 文件的全部内容</p></blockquote><h3 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2 搭建环境"></a>2 搭建环境</h3><h4 id="2-1-安装-Node-js"><a href="#2-1-安装-Node-js" class="headerlink" title="2.1 安装 Node.js"></a>2.1 安装 Node.js</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install -y nodejs npm<br></code></pre></td></tr></table></figure><h4 id="2-2-安装-Hexo"><a href="#2-2-安装-Hexo" class="headerlink" title="2.2 安装 Hexo"></a>2.2 安装 Hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo npm install hexo-cli -g<br></code></pre></td></tr></table></figure><h3 id="3-初始化-Hexo"><a href="#3-初始化-Hexo" class="headerlink" title="3 初始化 Hexo"></a>3 初始化 Hexo</h3><p>创建一个名为<code>blog</code>的文件夹，用于保存博客系统文件，可以通过以下命令初始化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>npm install hexo-deployer-git --save<br><br>hexo server<br></code></pre></td></tr></table></figure><p>初始化完成后可访问<a href="http://localhost:4000/">http://localhost:4000</a>预览页面。</p><h3 id="4-上传远端"><a href="#4-上传远端" class="headerlink" title="4 上传远端"></a>4 上传远端</h3><p>为了实现自动化部署，需要配置 hexo 并新建 Workflow。</p><p>修改<code>_config.yml</code>有关部署的配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repository: git@github.com:Username/Username.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure><p>博客根目录下创建<code>.github/workflows/deploy.yml</code>文件，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">blog (repository)<br>└── .github<br> └── workflows<br>  └── deploy.yml<br></code></pre></td></tr></table></figure><p><code>deploy.yml</code>的内容如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">name: CI<br><br>on:<br> push:<br>   branches:<br>     - master<br><br><span class="hljs-built_in">jobs</span>:<br> build:<br>   name: Build on node 12.x and ubuntu-18.04<br>   runs-on: ubuntu-18.04<br>   <span class="hljs-keyword">if</span>: github.event.repository.owner.id == github.event.sender.id<br><br>   steps:<br>     - name: Checkout<br>       uses: actions/checkout@v2<br>       with:<br>         ref: master<br><br>     - name: Use Node.js<br>       uses: actions/setup-node@v1<br>       with:<br>         node-version: <span class="hljs-string">&quot;12&quot;</span><br><br>     - name: Configuration environment<br>       <span class="hljs-built_in">env</span>:<br>         HEXO_DEPLOY_PRI: <span class="hljs-variable">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;</span>&#125;<br>       run: |<br>         sudo timedatectl set-timezone <span class="hljs-string">&quot;Asia/Shanghai&quot;</span><br>         <span class="hljs-built_in">mkdir</span> -p ~/.ssh/<br>         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HEXO_DEPLOY_PRI</span>&quot;</span> &gt; ~/.ssh/id_rsa<br>         <span class="hljs-built_in">chmod</span> 700 ~/.ssh<br>         <span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa<br>         ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts<br>         git config --global user.name <span class="hljs-string">&quot;你的GitHub用户名&quot;</span><br>         git config --global user.email <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br>         npm install hexo-cli -g<br>         npm install<br><br>     - name: Deploy hexo<br>       run: |<br>         hexo clean<br>         hexo deploy<br><br></code></pre></td></tr></table></figure><p>设置完成后，将本地仓库上传到私有仓库<code>blog</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git remote add origin https://github.com/Username/blog.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><p>配置无误的情况下即可在公开仓库中看到静态网页代码。</p><p>后续对博客更新时将待更新的文件放在<code>source/_post</code>目录下，然后将更新推送到远程分支即可。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/4a17b156/"/>
    <url>/posts/4a17b156/</url>
    
    <content type="html"><![CDATA[<h2 id="照亮黎明的曙光"><a href="#照亮黎明的曙光" class="headerlink" title="照亮黎明的曙光"></a>照亮黎明的曙光</h2><p>那些曾击垮过我的绝望</p><p>终将赋予我翱翔的力量</p><p>黑夜的一束光</p><p>我也触到了光芒</p><p>On and on and on and on</p><p>Until the dawn and on and on and on</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
